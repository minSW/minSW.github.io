{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo2/source/cover.png","path":"cover.png","modified":1,"renderable":1},{"_id":"themes/apollo2/source/css/apollo.css","path":"css/apollo.css","modified":1,"renderable":1},{"_id":"themes/apollo2/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":1,"renderable":1},{"_id":"themes/apollo2/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":1,"renderable":1},{"_id":"themes/apollo2/source/scss/apollo.scss","path":"scss/apollo.scss","modified":1,"renderable":1},{"_id":"themes/apollo2/source/tipuesearch/script.js","path":"tipuesearch/script.js","modified":1,"renderable":1},{"_id":"themes/apollo2/source/tipuesearch/tipuesearch.css","path":"tipuesearch/tipuesearch.css","modified":1,"renderable":1},{"_id":"themes/apollo2/source/tipuesearch/tipuesearch.js","path":"tipuesearch/tipuesearch.js","modified":1,"renderable":1},{"_id":"themes/apollo2/source/tipuesearch/tipuesearch_set.js","path":"tipuesearch/tipuesearch_set.js","modified":1,"renderable":1},{"_id":"themes/apollo2/source/tipuesearch/tipuesearch.min.js","path":"tipuesearch/tipuesearch.min.js","modified":1,"renderable":1},{"_id":"themes/apollo2/source/tipuesearch/tipuesearch_content.js","path":"tipuesearch/tipuesearch_content.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"c686e9a8587d92c1fea78576868b4f1ed3e68bc6","modified":1561910135571},{"_id":"themes/apollo2/.gitignore","hash":"661275fb4b21576e3a4db73e4f9994cec58bc490","modified":1552294615018},{"_id":"themes/apollo2/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1552294615018},{"_id":"themes/apollo2/README.md","hash":"7151c3b83c1c5613b87ebd86cc5ff2e1747e4a9b","modified":1552294615018},{"_id":"themes/apollo2/_config.yml","hash":"e37b8510239e83fee5aef5653e2fa508ee8a78d0","modified":1561910974910},{"_id":"themes/apollo2/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1552294615019},{"_id":"themes/apollo2/package.json","hash":"eb1e76ec0b7ed6c6c7b2bd32b4f1e1bbe15800ca","modified":1552294615024},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1562077930235},{"_id":"source/_posts/Kotlin-in-Action-1장.md","hash":"c9eb70d8a808a7f9f48aa3c7f9f42bc4773f39aa","modified":1562080653563},{"_id":"source/_posts/2019-NAVER-HACKDAY-SUMMER-후기.md","hash":"5f61390fec36e16a12282560b8259b6efd5a6e3b","modified":1561926059206},{"_id":"source/_posts/Kubernetes는-뭘까.md","hash":"9b523028fb7aba238d5de5b201b610ac47af96cd","modified":1561879116517},{"_id":"themes/apollo2/.git/FETCH_HEAD","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1561878763855},{"_id":"source/tags/index.md","hash":"43e7728edfb5e1273f51607bd3e602e8f2a28511","modified":1552294826513},{"_id":"themes/apollo2/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1552294615003},{"_id":"themes/apollo2/.git/config","hash":"2c37ecfc931f3b162e5c52f2cf836d93559ed432","modified":1552294615004},{"_id":"themes/apollo2/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1552294613721},{"_id":"themes/apollo2/.git/index","hash":"1d6c92ba51de54b64d7a3363189efd6c5f1160b3","modified":1561875236705},{"_id":"themes/apollo2/.git/packed-refs","hash":"f7dfbfab8d79ad7d0322501f6929342110689039","modified":1552294615000},{"_id":"themes/apollo2/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1552294615020},{"_id":"themes/apollo2/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1552294615021},{"_id":"themes/apollo2/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1552294615024},{"_id":"themes/apollo2/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1552294615020},{"_id":"themes/apollo2/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1552294615020},{"_id":"themes/apollo2/doc/doc-en.md","hash":"d6d9756b2085cdd8ee51eb5594427e2abf170e94","modified":1552294615019},{"_id":"themes/apollo2/doc/doc-zh.md","hash":"d43c1f6bff66426744a2c6f031d19ff09cdeb2d1","modified":1552294615019},{"_id":"themes/apollo2/source/cover.png","hash":"ecc14ede263ec96da5190eb9ca9bf84ab7cc414e","modified":1552294755315},{"_id":"themes/apollo2/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1552294613723},{"_id":"themes/apollo2/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1552294613722},{"_id":"themes/apollo2/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1552294613725},{"_id":"themes/apollo2/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1552294613725},{"_id":"themes/apollo2/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1552294613723},{"_id":"themes/apollo2/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1552294613726},{"_id":"themes/apollo2/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1552294613722},{"_id":"themes/apollo2/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1552294613724},{"_id":"themes/apollo2/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1552294613724},{"_id":"themes/apollo2/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1552294613726},{"_id":"themes/apollo2/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1552294613720},{"_id":"themes/apollo2/.git/logs/HEAD","hash":"3738346399869cf0357e31ce399790efc2c134ac","modified":1552294615003},{"_id":"themes/apollo2/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1552294615021},{"_id":"themes/apollo2/layout/mixins/post.jade","hash":"abf6e7e323225e17bda7dd1993260670d4864f01","modified":1552294615022},{"_id":"themes/apollo2/layout/partial/comment.jade","hash":"ef62c4ad88801c50621695fab5ebfa06ffc1ba04","modified":1552294615022},{"_id":"themes/apollo2/layout/partial/copyright.jade","hash":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1552294615022},{"_id":"themes/apollo2/layout/partial/head.jade","hash":"d83d3f5ce00e517d04287cdc68a80d61b65ec356","modified":1552294615023},{"_id":"themes/apollo2/layout/partial/layout.jade","hash":"443f510345259804ecb0db4ee33ec7fa40b93b54","modified":1552294615023},{"_id":"themes/apollo2/layout/partial/nav.jade","hash":"37be4e2a7d8502541c6337a0c03009c132f4b7cf","modified":1552295390587},{"_id":"themes/apollo2/layout/partial/scripts.jade","hash":"b7eaf885c31b994eedb111079593ecf0b35626bb","modified":1552294615023},{"_id":"themes/apollo2/source/css/apollo.css","hash":"b81a6575ae4cc2e6e357b134fddfb5fcd733f9a4","modified":1552294615025},{"_id":"themes/apollo2/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1552294615026},{"_id":"themes/apollo2/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1552294615026},{"_id":"themes/apollo2/source/scss/apollo.scss","hash":"46f0591031a7c72d829fdc0c3f11f076a521e78f","modified":1552294615030},{"_id":"themes/apollo2/source/tipuesearch/script.js","hash":"940da90c97e6cc4f9e7fa1efa6a79137e56029f9","modified":1552294615031},{"_id":"themes/apollo2/source/tipuesearch/tipuesearch.css","hash":"9df560d390336a73bdf56959a65338211848c491","modified":1552294615031},{"_id":"themes/apollo2/source/tipuesearch/tipuesearch.js","hash":"d93ef2815802049ba93fd6e07d29ee24c8fe59f9","modified":1552294615031},{"_id":"themes/apollo2/source/tipuesearch/tipuesearch_set.js","hash":"c00d35e13412b1470f269be8289e33d3f8668953","modified":1552294615032},{"_id":"themes/apollo2/source/tipuesearch/tipuesearch.min.js","hash":"934e9b85908b7c2a6963b33aef21a7f05e5ef3cb","modified":1552294615032},{"_id":"themes/apollo2/source/tipuesearch/tipuesearch_content.js","hash":"3ee8f7b059b4d085b879027edfd7eeee5346feb6","modified":1552294615032},{"_id":"themes/apollo2/.git/objects/pack/pack-442b5009907a49685ecc47b1a06efe4da6bf2f3b.idx","hash":"27b6671cb6e532fd4998dc8c195106bac0c19cc0","modified":1552294614991},{"_id":"themes/apollo2/.git/refs/heads/master","hash":"992b6d3f3621f35ed760f924f72da057e0ef413e","modified":1552294615003},{"_id":"themes/apollo2/source/scss/_partial/archive-post-list.scss","hash":"1b36d884723c9c0aefdb7aaccadc2f13d3c239d1","modified":1552294615027},{"_id":"themes/apollo2/source/scss/_partial/base.scss","hash":"ae967b2049ecb9b8c4e139ecce32fd9fb5358ac5","modified":1552294615027},{"_id":"themes/apollo2/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1552294615028},{"_id":"themes/apollo2/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1552294615028},{"_id":"themes/apollo2/source/scss/_partial/header.scss","hash":"e9ef3beee7c55d7ec6b072699b18e4f5794dba3c","modified":1552294615028},{"_id":"themes/apollo2/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1552294615029},{"_id":"themes/apollo2/source/scss/_partial/mq.scss","hash":"ce84550c08a350ac72fe81914e3afdd9a9ab6ae5","modified":1552294615029},{"_id":"themes/apollo2/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1552294615029},{"_id":"themes/apollo2/source/scss/_partial/other.scss","hash":"02062210417c346b1c0ba4857c4e3f78c82c079b","modified":1552294615030},{"_id":"themes/apollo2/source/scss/_partial/post.scss","hash":"6f238c44fdd4f4e897ae5e1de7af3d6102cecceb","modified":1552294615030},{"_id":"themes/apollo2/.git/logs/refs/heads/master","hash":"3738346399869cf0357e31ce399790efc2c134ac","modified":1552294615004},{"_id":"themes/apollo2/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1552294615002},{"_id":"themes/apollo2/.git/logs/refs/remotes/origin/HEAD","hash":"3738346399869cf0357e31ce399790efc2c134ac","modified":1552294615002},{"_id":"themes/apollo2/.git/objects/pack/pack-442b5009907a49685ecc47b1a06efe4da6bf2f3b.pack","hash":"348b9a61e4671fa22d82011a7dc54107756165d8","modified":1552294614991},{"_id":"public/feed.xml","hash":"5cc09ce58ce1c7cd3d816f4e72f92e8468b11dc8","modified":1562080686466},{"_id":"public/sitemap.xml","hash":"4891feab4732adb7a45a856f7f4de6c7ddf7447a","modified":1562080686466},{"_id":"public/tags/index.html","hash":"6457f2f94c37ec98956d48b807b3be215744ed75","modified":1562080686472},{"_id":"public/2019/07/02/Kotlin-in-Action-1장/index.html","hash":"b799d7c5aea78f595e2ff4120f0765ea44519f3e","modified":1562080686472},{"_id":"public/archives/index.html","hash":"3518ff53de10855a6d624d39469bc80142ac42e9","modified":1562080686472},{"_id":"public/categories/kotlin/index.html","hash":"3e84c8813b95d02993c56c252bfcd72aa09f5622","modified":1562080686473},{"_id":"public/categories/kubernetes/index.html","hash":"823bfe58db0f2c4493bb83635bc3e3b849b13d41","modified":1562080686473},{"_id":"public/categories/retrospect/index.html","hash":"7f02553138862fcf37efe224f441d5614f185792","modified":1562080686473},{"_id":"public/index.html","hash":"be8045be0279ce94ac5c620d423601037ce4e037","modified":1562080686473},{"_id":"public/tags/kotlin/index.html","hash":"dbb3b85a9877d1f5b0889e419560ad1559feca99","modified":1562080686473},{"_id":"public/tags/study/index.html","hash":"dbb3b85a9877d1f5b0889e419560ad1559feca99","modified":1562080686473},{"_id":"public/tags/summarization/index.html","hash":"dbb3b85a9877d1f5b0889e419560ad1559feca99","modified":1562080686473},{"_id":"public/tags/book/index.html","hash":"dbb3b85a9877d1f5b0889e419560ad1559feca99","modified":1562080686473},{"_id":"public/tags/kubernetes/index.html","hash":"8d0dafea325c13b63755c8a29e4475dbbd9d937a","modified":1562080686473},{"_id":"public/tags/k8s/index.html","hash":"8d0dafea325c13b63755c8a29e4475dbbd9d937a","modified":1562080686473},{"_id":"public/tags/container/index.html","hash":"8da66b68a262e47c71f1146d27e4362253dd5a64","modified":1562080686473},{"_id":"public/tags/CNCF/index.html","hash":"8da66b68a262e47c71f1146d27e4362253dd5a64","modified":1562080686473},{"_id":"public/tags/naver/index.html","hash":"62205c00e71be59d0b9aa6095392ed7919a38273","modified":1562080686473},{"_id":"public/tags/hackathon/index.html","hash":"62205c00e71be59d0b9aa6095392ed7919a38273","modified":1562080686473},{"_id":"public/tags/kafka/index.html","hash":"62205c00e71be59d0b9aa6095392ed7919a38273","modified":1562080686474},{"_id":"public/2019/06/30/2019-NAVER-HACKDAY-SUMMER-후기/index.html","hash":"84b960e2fddcc391e19a6eee9a0c3136c65f9850","modified":1562080686474},{"_id":"public/2019/01/26/Kubernetes는-뭘까/index.html","hash":"63c736549cb0094be6576ab0553d8e1200a8cc53","modified":1562080686474},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1562080686476},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1562080686476},{"_id":"public/scss/apollo.scss","hash":"46f0591031a7c72d829fdc0c3f11f076a521e78f","modified":1562080686476},{"_id":"public/cover.png","hash":"ecc14ede263ec96da5190eb9ca9bf84ab7cc414e","modified":1562080686478},{"_id":"public/tipuesearch/script.js","hash":"940da90c97e6cc4f9e7fa1efa6a79137e56029f9","modified":1562080686480},{"_id":"public/tipuesearch/tipuesearch.css","hash":"9df560d390336a73bdf56959a65338211848c491","modified":1562080686480},{"_id":"public/tipuesearch/tipuesearch_set.js","hash":"c00d35e13412b1470f269be8289e33d3f8668953","modified":1562080686481},{"_id":"public/tipuesearch/tipuesearch_content.js","hash":"3ee8f7b059b4d085b879027edfd7eeee5346feb6","modified":1562080686481},{"_id":"public/tipuesearch/tipuesearch.min.js","hash":"934e9b85908b7c2a6963b33aef21a7f05e5ef3cb","modified":1562080686483},{"_id":"public/css/apollo.css","hash":"b81a6575ae4cc2e6e357b134fddfb5fcd733f9a4","modified":1562080686485},{"_id":"public/tipuesearch/tipuesearch.js","hash":"d93ef2815802049ba93fd6e07d29ee24c8fe59f9","modified":1562080686488}],"Category":[{"name":"kotlin","_id":"cjxlyib2m00021n4yw4hf6vo4"},{"name":"kubernetes","_id":"cjxlyibcy000e1n4y9k38c21g"},{"name":"retrospect","_id":"cjxlyibcy000g1n4y5d267i7o"}],"Data":[],"Page":[{"title":"tags","date":"2019-03-11T09:00:26.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-03-11 18:00:26\n---\n","updated":"2019-03-11T09:00:26.513Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjxlyib2k00011n4y4g03b95w","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"'Kotlin in Action' 1장 - 코틀린 (Kotlin) 이란?","date":"2019-07-02T14:07:55.000Z","_content":"\n<br/>\n\n#### 'Kotlin in Action'\n공부 겸 프로젝트 준비 겸 Kotlin 책을 하나 샀다.\n***'Kotlin in Action'*** 은 Kotlin 언어를 개발한 JetBrains 개발자들이 직접 쓴 책으로, <u>Kotlin 다운 Kotlin 개발</u>을 하기 위해 첫 단추로 택했다.\n내가 책 읽는 속도는 빠른데 머리에서 휘발되는 속도도 빠른 편이라(...) 시간 날 때 마다 읽은 부분은 차근차근 정리 해두려고 한다. \n> **Kotlin**은 *최신 멀티플랫폼 애플리케이션을 위한 정적 타입 언어* 로,\n> 2017 Google I/O에서 안드로이드 공식언어로 선정되었고 현재 1.3 버전까지 릴리즈 되어있다.\n> \n> Kotlin 공식 페이지 https://kotlinlang.org/\n\n\n<center><h2>_ _ _</h2></center>\n\n<br/>\n\n---\n\n## Overview\n#### Java 를 대신할 언어에 대한 Requirement 3가지\n1. 정적 타입 지정 (static typing)\n2. 기존 자바 코드와의 완전한 호환성\n3. 해당 언어를 위한 도구 개발 복잡성 x\n\n⇒ 배우고 이해하기 쉬우며 대규모 개발/유지보수성/기존 자바와의 호환성에 적합한 강력한 언어, <u>**'Kotlin'**</u>\n\n<br/>\n\n# 1장. 코틀린이란, 무엇이며 왜 필요한가?\n\nKotlin은 자바 플랫폼에서 돌아가는 새로운 프로그래밍 언어다.\n**간결하고 실용적**이며 **Java 코드와의 상호운용성** (interoperability)을 중시한다.\n\n## 특성\n#### 1. 대상 플랫폼 : 자바가 실행되는 Everywhere\n\n일부가 아닌 개발 과정에서 수행해야하는 모든 과업에 있어 폭넓게 생산성을 향상 시킨다.\n구체적인 영역 or 특정 프로그램 패러다임을 지원하는 여러 라이브러리와의 융합성 ↑\n\n<br/>\n\n#### 2. 정적 타입 지정 언어\n\nKotlin은 **정적 타입 지정 언어** 이면서, <u>type inference</u> (타입추론) 과 <u>nullable type</u>을 지원한다.\n⇒ 프로그래머의 불편함 해소 & 컴파일 시점에 NPE 여부 검사 가능\n\n\n* **정적 타입** (statically typed) 지정 언어 : Java, Kotlin ..\n\n\t> 모든 프로그램 구성 요소 타입을 컴파일 시점에 알 수 있고, 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증한다.\n\n\t장점 : 성능 / 신뢰성 / 유지 보수성 / 도구 지원 _ `p.36`\n\t\n\t<br/>\n\n* **동적 타입** (dynamically typed) 지정 언어 : Groovy, JRuby ...\n\n\t> 타입과 관계없이 모든 값을 변수에 넣을 수 있고, 필드나 메소드 접근에 대한 검증이 실행 시점에 일어난다. \n\t\n\t동적이 더 유연하고 코드도 짧아지지만, 오류를 사전에 거르지 못하고 Runtime Error 발생 가능성 존재\n\n<br/>\n\n#### 3. 함수형 / 객체지향 프로그래밍\n\nKotlin으로 코드를 작성 할 땐, Java와 같은 <u>객체지향 프로그래밍 (OOP)</u> 과 <u>함수형 프로그래밍</u> 접근 방법을 조합해서 문제에 가장 적합한 도구를 사용하면 된다.\n\n> **함수형 프로그래밍** 의 핵심 개념\n> \n> * first-class function (일급 함수)\n> * immutability\n> * no side effect _ pure function\n> \n\n<br/>\n\n#### 4. 무료 오픈소스\n\nKotlin 언어와 이와 관련된 모든 도구는 오픈소스이다.\n(https://github.com/jetbrains/kotlin - Apache2 License.)\n\n\n<br/>\n\n## 응용\n#### 코틀린 서버 프로그래밍\n> **서버 프로그래밍** 의 범위\n> \n> * 브라우저에 HTML 페이지를 반환하는 웹 애플리케이션\n> * 모바일 애플리케이션에게 HTTP를 통해 JSON API를  \n> * RPC (Remote Procedure Call) 프로토콜을 통해 서로 통신하는 마이크로 서비스\n> \n\nKotlin은 이러한 애플리케이션 개발에 도움을 주는 기존의 자바 프레임워크나 기술과 매끄럽게 상호운용 가능하다.\n\n\\+ 새로운 기술도 적용 가능 (ex. Kotlin의 Builder Pattern, Persistence Framework ...)\n  ⇒ `7.5절` & `11장` 에서 좀 더 자세히\n\n<br/>\n\n#### 코틀린 안드로이드 프로그래밍\n\n모바일 애플리케이션은 전형적인 엔터프라이즈 애플리케이션보다 더 작고 기존과 신규 코드 통합 필요성도 더 적고, 다양한 디바이스에 대한 서비스 신뢰성 보장과 빠른 개발&배포가 필요하다.\n\nKotlin 언어의 특성과 특별한 컴파일러 플러그인 지원을 조합하면 개발 생산성을 더 높일 수 있다.\n뿐만 아니라 애플리케이션 신뢰성 향상, 자바6와 완전한 호환, 성능 손실 x 과 같은 장점도 취할 수 있다.\n\n\\+ 참조 _ 안드로이드 API에 대한 Kotlin Adaptor를 제공하고 있는 **Anko Library** https://github.com/kotlin/anko\n\n<br/>\n\n## 철학\n> 대개 Kotlin은 Java와의 ***상호운용성*** 에 초점을 맞춘 ***실용적*** 이고 ***간결*** 하며 ***안전한*** 언어로 표현된다.\n> \n\n#### 실용성\n\n- 연구를 위한 언어가 아닌, 실제 문제를 해결하기 위해 만들어진 실용적인 언어이다.\n- 특정 프로그래밍 스타일이나 패러다임 사용을 강제하지 않는다.\n- 도구를 강조한다. (IDE 지원)\n\n<br/>\n\n#### 간결성\n\n- 기존 코드 이해가 더 쉬워진다. (→ 생산성과 개발 속도 향상)\n- 부수적인 요소등을 묵시적으로 제공하여 코드가 깔끔하다.\n- 람다를 지원한다.\n- 그러나 소스코드를 가능한 짧게 만드는 것이 코틀린의 설계 목표는 아니다.\n\n<br/>\n\n#### 안전성\n\n  프로그램의 안전성과 생산성 사이에는 trade-off 존재\n\n- JVM에서 실행한다. (메모리 안전성과 버퍼 플로우 방지등 기본적으로 높은 안전성 확보)\n- 정적 타입 지정 언어으로, 애플리케이션의 타입 안전성을 보장한다.\n- 실행 시점이 아닌 컴파일 시점에 검사를 통해 더 많은 오류를 방지해준다. (ex. `NullPointerException`, `ClassCastException`)\n\n<br/>\n\n#### 상호운용성\n\n- Java의 기존 라이브러리를 그대로 사용 가능하고, 최대한 활용하고 있다.\n- Java ←→ Kotlin 호출에 따로 노력이 필요하지 않다.\n- 다중 언어 프로젝트를 완전히 지원한다.\n\n<br/>\n\n## 코틀린 도구 사용\n\nKotlin도 Java와 마찬가지로 컴파일 언어이다.\n![kotlin-runtime-diagram](https://user-images.githubusercontent.com/26691216/60521297-f6b43e80-9d21-11e9-956b-4f827ed75f1b.jpg)\n<center><i>Kotlin Build Process</i></center>\n\n<br/>\n\n\n#### 자바-코틀린 변환\nIntellij IDEA에서는 자바 코드 조각을 코틀린 파일(.kt)에 붙여넣기\n자바 파일 자체를 변환하려면 `Code > Convert Java File to Kotlin File` \n\n도구에 대해서는 필요에 따라 쓰면 되는거라 나머지 내용 생략.\n\n<br/>\n\n### 1장 요약 `p.57`","source":"_posts/Kotlin-in-Action-1장.md","raw":"---\ntitle: '''Kotlin in Action'' 1장 - 코틀린 (Kotlin) 이란?'\ndate: 2019-07-02 23:07:55\ncategories: kotlin\ntags:\n\t- kotlin\n\t- study\n\t- book\n\t- summarization\n---\n\n<br/>\n\n#### 'Kotlin in Action'\n공부 겸 프로젝트 준비 겸 Kotlin 책을 하나 샀다.\n***'Kotlin in Action'*** 은 Kotlin 언어를 개발한 JetBrains 개발자들이 직접 쓴 책으로, <u>Kotlin 다운 Kotlin 개발</u>을 하기 위해 첫 단추로 택했다.\n내가 책 읽는 속도는 빠른데 머리에서 휘발되는 속도도 빠른 편이라(...) 시간 날 때 마다 읽은 부분은 차근차근 정리 해두려고 한다. \n> **Kotlin**은 *최신 멀티플랫폼 애플리케이션을 위한 정적 타입 언어* 로,\n> 2017 Google I/O에서 안드로이드 공식언어로 선정되었고 현재 1.3 버전까지 릴리즈 되어있다.\n> \n> Kotlin 공식 페이지 https://kotlinlang.org/\n\n\n<center><h2>_ _ _</h2></center>\n\n<br/>\n\n---\n\n## Overview\n#### Java 를 대신할 언어에 대한 Requirement 3가지\n1. 정적 타입 지정 (static typing)\n2. 기존 자바 코드와의 완전한 호환성\n3. 해당 언어를 위한 도구 개발 복잡성 x\n\n⇒ 배우고 이해하기 쉬우며 대규모 개발/유지보수성/기존 자바와의 호환성에 적합한 강력한 언어, <u>**'Kotlin'**</u>\n\n<br/>\n\n# 1장. 코틀린이란, 무엇이며 왜 필요한가?\n\nKotlin은 자바 플랫폼에서 돌아가는 새로운 프로그래밍 언어다.\n**간결하고 실용적**이며 **Java 코드와의 상호운용성** (interoperability)을 중시한다.\n\n## 특성\n#### 1. 대상 플랫폼 : 자바가 실행되는 Everywhere\n\n일부가 아닌 개발 과정에서 수행해야하는 모든 과업에 있어 폭넓게 생산성을 향상 시킨다.\n구체적인 영역 or 특정 프로그램 패러다임을 지원하는 여러 라이브러리와의 융합성 ↑\n\n<br/>\n\n#### 2. 정적 타입 지정 언어\n\nKotlin은 **정적 타입 지정 언어** 이면서, <u>type inference</u> (타입추론) 과 <u>nullable type</u>을 지원한다.\n⇒ 프로그래머의 불편함 해소 & 컴파일 시점에 NPE 여부 검사 가능\n\n\n* **정적 타입** (statically typed) 지정 언어 : Java, Kotlin ..\n\n\t> 모든 프로그램 구성 요소 타입을 컴파일 시점에 알 수 있고, 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증한다.\n\n\t장점 : 성능 / 신뢰성 / 유지 보수성 / 도구 지원 _ `p.36`\n\t\n\t<br/>\n\n* **동적 타입** (dynamically typed) 지정 언어 : Groovy, JRuby ...\n\n\t> 타입과 관계없이 모든 값을 변수에 넣을 수 있고, 필드나 메소드 접근에 대한 검증이 실행 시점에 일어난다. \n\t\n\t동적이 더 유연하고 코드도 짧아지지만, 오류를 사전에 거르지 못하고 Runtime Error 발생 가능성 존재\n\n<br/>\n\n#### 3. 함수형 / 객체지향 프로그래밍\n\nKotlin으로 코드를 작성 할 땐, Java와 같은 <u>객체지향 프로그래밍 (OOP)</u> 과 <u>함수형 프로그래밍</u> 접근 방법을 조합해서 문제에 가장 적합한 도구를 사용하면 된다.\n\n> **함수형 프로그래밍** 의 핵심 개념\n> \n> * first-class function (일급 함수)\n> * immutability\n> * no side effect _ pure function\n> \n\n<br/>\n\n#### 4. 무료 오픈소스\n\nKotlin 언어와 이와 관련된 모든 도구는 오픈소스이다.\n(https://github.com/jetbrains/kotlin - Apache2 License.)\n\n\n<br/>\n\n## 응용\n#### 코틀린 서버 프로그래밍\n> **서버 프로그래밍** 의 범위\n> \n> * 브라우저에 HTML 페이지를 반환하는 웹 애플리케이션\n> * 모바일 애플리케이션에게 HTTP를 통해 JSON API를  \n> * RPC (Remote Procedure Call) 프로토콜을 통해 서로 통신하는 마이크로 서비스\n> \n\nKotlin은 이러한 애플리케이션 개발에 도움을 주는 기존의 자바 프레임워크나 기술과 매끄럽게 상호운용 가능하다.\n\n\\+ 새로운 기술도 적용 가능 (ex. Kotlin의 Builder Pattern, Persistence Framework ...)\n  ⇒ `7.5절` & `11장` 에서 좀 더 자세히\n\n<br/>\n\n#### 코틀린 안드로이드 프로그래밍\n\n모바일 애플리케이션은 전형적인 엔터프라이즈 애플리케이션보다 더 작고 기존과 신규 코드 통합 필요성도 더 적고, 다양한 디바이스에 대한 서비스 신뢰성 보장과 빠른 개발&배포가 필요하다.\n\nKotlin 언어의 특성과 특별한 컴파일러 플러그인 지원을 조합하면 개발 생산성을 더 높일 수 있다.\n뿐만 아니라 애플리케이션 신뢰성 향상, 자바6와 완전한 호환, 성능 손실 x 과 같은 장점도 취할 수 있다.\n\n\\+ 참조 _ 안드로이드 API에 대한 Kotlin Adaptor를 제공하고 있는 **Anko Library** https://github.com/kotlin/anko\n\n<br/>\n\n## 철학\n> 대개 Kotlin은 Java와의 ***상호운용성*** 에 초점을 맞춘 ***실용적*** 이고 ***간결*** 하며 ***안전한*** 언어로 표현된다.\n> \n\n#### 실용성\n\n- 연구를 위한 언어가 아닌, 실제 문제를 해결하기 위해 만들어진 실용적인 언어이다.\n- 특정 프로그래밍 스타일이나 패러다임 사용을 강제하지 않는다.\n- 도구를 강조한다. (IDE 지원)\n\n<br/>\n\n#### 간결성\n\n- 기존 코드 이해가 더 쉬워진다. (→ 생산성과 개발 속도 향상)\n- 부수적인 요소등을 묵시적으로 제공하여 코드가 깔끔하다.\n- 람다를 지원한다.\n- 그러나 소스코드를 가능한 짧게 만드는 것이 코틀린의 설계 목표는 아니다.\n\n<br/>\n\n#### 안전성\n\n  프로그램의 안전성과 생산성 사이에는 trade-off 존재\n\n- JVM에서 실행한다. (메모리 안전성과 버퍼 플로우 방지등 기본적으로 높은 안전성 확보)\n- 정적 타입 지정 언어으로, 애플리케이션의 타입 안전성을 보장한다.\n- 실행 시점이 아닌 컴파일 시점에 검사를 통해 더 많은 오류를 방지해준다. (ex. `NullPointerException`, `ClassCastException`)\n\n<br/>\n\n#### 상호운용성\n\n- Java의 기존 라이브러리를 그대로 사용 가능하고, 최대한 활용하고 있다.\n- Java ←→ Kotlin 호출에 따로 노력이 필요하지 않다.\n- 다중 언어 프로젝트를 완전히 지원한다.\n\n<br/>\n\n## 코틀린 도구 사용\n\nKotlin도 Java와 마찬가지로 컴파일 언어이다.\n![kotlin-runtime-diagram](https://user-images.githubusercontent.com/26691216/60521297-f6b43e80-9d21-11e9-956b-4f827ed75f1b.jpg)\n<center><i>Kotlin Build Process</i></center>\n\n<br/>\n\n\n#### 자바-코틀린 변환\nIntellij IDEA에서는 자바 코드 조각을 코틀린 파일(.kt)에 붙여넣기\n자바 파일 자체를 변환하려면 `Code > Convert Java File to Kotlin File` \n\n도구에 대해서는 필요에 따라 쓰면 되는거라 나머지 내용 생략.\n\n<br/>\n\n### 1장 요약 `p.57`","slug":"Kotlin-in-Action-1장","published":1,"updated":"2019-07-02T15:17:33.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxlyib2g00001n4y6f1f69fr","content":"<p><br></p>\n<h4 id=\"‘Kotlin-in-Action’\"><a href=\"#‘Kotlin-in-Action’\" class=\"headerlink\" title=\"‘Kotlin in Action’\"></a>‘Kotlin in Action’</h4><p>공부 겸 프로젝트 준비 겸 Kotlin 책을 하나 샀다.<br><strong><em>‘Kotlin in Action’</em></strong> 은 Kotlin 언어를 개발한 JetBrains 개발자들이 직접 쓴 책으로, <u>Kotlin 다운 Kotlin 개발</u>을 하기 위해 첫 단추로 택했다.<br>내가 책 읽는 속도는 빠른데 머리에서 휘발되는 속도도 빠른 편이라(…) 시간 날 때 마다 읽은 부분은 차근차근 정리 해두려고 한다. </p>\n<blockquote>\n<p><strong>Kotlin</strong>은 <em>최신 멀티플랫폼 애플리케이션을 위한 정적 타입 언어</em> 로,<br>2017 Google I/O에서 안드로이드 공식언어로 선정되었고 현재 1.3 버전까지 릴리즈 되어있다.</p>\n<p>Kotlin 공식 페이지 <a href=\"https://kotlinlang.org/\" target=\"_blank\" rel=\"noopener\">https://kotlinlang.org/</a></p>\n</blockquote>\n<center><h2>_ _ _</h2></center>\n\n<p><br></p>\n<hr>\n<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><h4 id=\"Java-를-대신할-언어에-대한-Requirement-3가지\"><a href=\"#Java-를-대신할-언어에-대한-Requirement-3가지\" class=\"headerlink\" title=\"Java 를 대신할 언어에 대한 Requirement 3가지\"></a>Java 를 대신할 언어에 대한 Requirement 3가지</h4><ol>\n<li>정적 타입 지정 (static typing)</li>\n<li>기존 자바 코드와의 완전한 호환성</li>\n<li>해당 언어를 위한 도구 개발 복잡성 x</li>\n</ol>\n<p>⇒ 배우고 이해하기 쉬우며 대규모 개발/유지보수성/기존 자바와의 호환성에 적합한 강력한 언어, <u><strong>‘Kotlin’</strong></u></p>\n<p><br></p>\n<h1 id=\"1장-코틀린이란-무엇이며-왜-필요한가\"><a href=\"#1장-코틀린이란-무엇이며-왜-필요한가\" class=\"headerlink\" title=\"1장. 코틀린이란, 무엇이며 왜 필요한가?\"></a>1장. 코틀린이란, 무엇이며 왜 필요한가?</h1><p>Kotlin은 자바 플랫폼에서 돌아가는 새로운 프로그래밍 언어다.<br><strong>간결하고 실용적</strong>이며 <strong>Java 코드와의 상호운용성</strong> (interoperability)을 중시한다.</p>\n<h2 id=\"특성\"><a href=\"#특성\" class=\"headerlink\" title=\"특성\"></a>특성</h2><h4 id=\"1-대상-플랫폼-자바가-실행되는-Everywhere\"><a href=\"#1-대상-플랫폼-자바가-실행되는-Everywhere\" class=\"headerlink\" title=\"1. 대상 플랫폼 : 자바가 실행되는 Everywhere\"></a>1. 대상 플랫폼 : 자바가 실행되는 Everywhere</h4><p>일부가 아닌 개발 과정에서 수행해야하는 모든 과업에 있어 폭넓게 생산성을 향상 시킨다.<br>구체적인 영역 or 특정 프로그램 패러다임을 지원하는 여러 라이브러리와의 융합성 ↑</p>\n<p><br></p>\n<h4 id=\"2-정적-타입-지정-언어\"><a href=\"#2-정적-타입-지정-언어\" class=\"headerlink\" title=\"2. 정적 타입 지정 언어\"></a>2. 정적 타입 지정 언어</h4><p>Kotlin은 <strong>정적 타입 지정 언어</strong> 이면서, <u>type inference</u> (타입추론) 과 <u>nullable type</u>을 지원한다.<br>⇒ 프로그래머의 불편함 해소 &amp; 컴파일 시점에 NPE 여부 검사 가능</p>\n<ul>\n<li><p><strong>정적 타입</strong> (statically typed) 지정 언어 : Java, Kotlin ..</p>\n<blockquote>\n<p>모든 프로그램 구성 요소 타입을 컴파일 시점에 알 수 있고, 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증한다.</p>\n</blockquote>\n<p>  장점 : 성능 / 신뢰성 / 유지 보수성 / 도구 지원 _ <code>p.36</code></p>\n<p>  <br></p>\n</li>\n<li><p><strong>동적 타입</strong> (dynamically typed) 지정 언어 : Groovy, JRuby …</p>\n<blockquote>\n<p>타입과 관계없이 모든 값을 변수에 넣을 수 있고, 필드나 메소드 접근에 대한 검증이 실행 시점에 일어난다. </p>\n</blockquote>\n<p>  동적이 더 유연하고 코드도 짧아지지만, 오류를 사전에 거르지 못하고 Runtime Error 발생 가능성 존재</p>\n</li>\n</ul>\n<p><br></p>\n<h4 id=\"3-함수형-객체지향-프로그래밍\"><a href=\"#3-함수형-객체지향-프로그래밍\" class=\"headerlink\" title=\"3. 함수형 / 객체지향 프로그래밍\"></a>3. 함수형 / 객체지향 프로그래밍</h4><p>Kotlin으로 코드를 작성 할 땐, Java와 같은 <u>객체지향 프로그래밍 (OOP)</u> 과 <u>함수형 프로그래밍</u> 접근 방법을 조합해서 문제에 가장 적합한 도구를 사용하면 된다.</p>\n<blockquote>\n<p><strong>함수형 프로그래밍</strong> 의 핵심 개념</p>\n<ul>\n<li>first-class function (일급 함수)</li>\n<li>immutability</li>\n<li>no side effect _ pure function</li>\n</ul>\n</blockquote>\n<p><br></p>\n<h4 id=\"4-무료-오픈소스\"><a href=\"#4-무료-오픈소스\" class=\"headerlink\" title=\"4. 무료 오픈소스\"></a>4. 무료 오픈소스</h4><p>Kotlin 언어와 이와 관련된 모든 도구는 오픈소스이다.<br>(<a href=\"https://github.com/jetbrains/kotlin\" target=\"_blank\" rel=\"noopener\">https://github.com/jetbrains/kotlin</a> - Apache2 License.)</p>\n<p><br></p>\n<h2 id=\"응용\"><a href=\"#응용\" class=\"headerlink\" title=\"응용\"></a>응용</h2><h4 id=\"코틀린-서버-프로그래밍\"><a href=\"#코틀린-서버-프로그래밍\" class=\"headerlink\" title=\"코틀린 서버 프로그래밍\"></a>코틀린 서버 프로그래밍</h4><blockquote>\n<p><strong>서버 프로그래밍</strong> 의 범위</p>\n<ul>\n<li>브라우저에 HTML 페이지를 반환하는 웹 애플리케이션</li>\n<li>모바일 애플리케이션에게 HTTP를 통해 JSON API를  </li>\n<li>RPC (Remote Procedure Call) 프로토콜을 통해 서로 통신하는 마이크로 서비스</li>\n</ul>\n</blockquote>\n<p>Kotlin은 이러한 애플리케이션 개발에 도움을 주는 기존의 자바 프레임워크나 기술과 매끄럽게 상호운용 가능하다.</p>\n<p>+ 새로운 기술도 적용 가능 (ex. Kotlin의 Builder Pattern, Persistence Framework …)<br>  ⇒ <code>7.5절</code> &amp; <code>11장</code> 에서 좀 더 자세히</p>\n<p><br></p>\n<h4 id=\"코틀린-안드로이드-프로그래밍\"><a href=\"#코틀린-안드로이드-프로그래밍\" class=\"headerlink\" title=\"코틀린 안드로이드 프로그래밍\"></a>코틀린 안드로이드 프로그래밍</h4><p>모바일 애플리케이션은 전형적인 엔터프라이즈 애플리케이션보다 더 작고 기존과 신규 코드 통합 필요성도 더 적고, 다양한 디바이스에 대한 서비스 신뢰성 보장과 빠른 개발&amp;배포가 필요하다.</p>\n<p>Kotlin 언어의 특성과 특별한 컴파일러 플러그인 지원을 조합하면 개발 생산성을 더 높일 수 있다.<br>뿐만 아니라 애플리케이션 신뢰성 향상, 자바6와 완전한 호환, 성능 손실 x 과 같은 장점도 취할 수 있다.</p>\n<p>+ 참조 _ 안드로이드 API에 대한 Kotlin Adaptor를 제공하고 있는 <strong>Anko Library</strong> <a href=\"https://github.com/kotlin/anko\" target=\"_blank\" rel=\"noopener\">https://github.com/kotlin/anko</a></p>\n<p><br></p>\n<h2 id=\"철학\"><a href=\"#철학\" class=\"headerlink\" title=\"철학\"></a>철학</h2><blockquote>\n<p>대개 Kotlin은 Java와의 <strong><em>상호운용성</em></strong> 에 초점을 맞춘 <strong><em>실용적</em></strong> 이고 <strong><em>간결</em></strong> 하며 <strong><em>안전한</em></strong> 언어로 표현된다.</p>\n</blockquote>\n<h4 id=\"실용성\"><a href=\"#실용성\" class=\"headerlink\" title=\"실용성\"></a>실용성</h4><ul>\n<li>연구를 위한 언어가 아닌, 실제 문제를 해결하기 위해 만들어진 실용적인 언어이다.</li>\n<li>특정 프로그래밍 스타일이나 패러다임 사용을 강제하지 않는다.</li>\n<li>도구를 강조한다. (IDE 지원)</li>\n</ul>\n<p><br></p>\n<h4 id=\"간결성\"><a href=\"#간결성\" class=\"headerlink\" title=\"간결성\"></a>간결성</h4><ul>\n<li>기존 코드 이해가 더 쉬워진다. (→ 생산성과 개발 속도 향상)</li>\n<li>부수적인 요소등을 묵시적으로 제공하여 코드가 깔끔하다.</li>\n<li>람다를 지원한다.</li>\n<li>그러나 소스코드를 가능한 짧게 만드는 것이 코틀린의 설계 목표는 아니다.</li>\n</ul>\n<p><br></p>\n<h4 id=\"안전성\"><a href=\"#안전성\" class=\"headerlink\" title=\"안전성\"></a>안전성</h4><p>  프로그램의 안전성과 생산성 사이에는 trade-off 존재</p>\n<ul>\n<li>JVM에서 실행한다. (메모리 안전성과 버퍼 플로우 방지등 기본적으로 높은 안전성 확보)</li>\n<li>정적 타입 지정 언어으로, 애플리케이션의 타입 안전성을 보장한다.</li>\n<li>실행 시점이 아닌 컴파일 시점에 검사를 통해 더 많은 오류를 방지해준다. (ex. <code>NullPointerException</code>, <code>ClassCastException</code>)</li>\n</ul>\n<p><br></p>\n<h4 id=\"상호운용성\"><a href=\"#상호운용성\" class=\"headerlink\" title=\"상호운용성\"></a>상호운용성</h4><ul>\n<li>Java의 기존 라이브러리를 그대로 사용 가능하고, 최대한 활용하고 있다.</li>\n<li>Java ←→ Kotlin 호출에 따로 노력이 필요하지 않다.</li>\n<li>다중 언어 프로젝트를 완전히 지원한다.</li>\n</ul>\n<p><br></p>\n<h2 id=\"코틀린-도구-사용\"><a href=\"#코틀린-도구-사용\" class=\"headerlink\" title=\"코틀린 도구 사용\"></a>코틀린 도구 사용</h2><p>Kotlin도 Java와 마찬가지로 컴파일 언어이다.<br><img src=\"https://user-images.githubusercontent.com/26691216/60521297-f6b43e80-9d21-11e9-956b-4f827ed75f1b.jpg\" alt=\"kotlin-runtime-diagram\"></p>\n<center><i>Kotlin Build Process</i></center>\n\n<p><br></p>\n<h4 id=\"자바-코틀린-변환\"><a href=\"#자바-코틀린-변환\" class=\"headerlink\" title=\"자바-코틀린 변환\"></a>자바-코틀린 변환</h4><p>Intellij IDEA에서는 자바 코드 조각을 코틀린 파일(.kt)에 붙여넣기<br>자바 파일 자체를 변환하려면 <code>Code &gt; Convert Java File to Kotlin File</code> </p>\n<p>도구에 대해서는 필요에 따라 쓰면 되는거라 나머지 내용 생략.</p>\n<p><br></p>\n<h3 id=\"1장-요약-p-57\"><a href=\"#1장-요약-p-57\" class=\"headerlink\" title=\"1장 요약 p.57\"></a>1장 요약 <code>p.57</code></h3>","site":{"data":{}},"excerpt":"","more":"<p><br></p>\n<h4 id=\"‘Kotlin-in-Action’\"><a href=\"#‘Kotlin-in-Action’\" class=\"headerlink\" title=\"‘Kotlin in Action’\"></a>‘Kotlin in Action’</h4><p>공부 겸 프로젝트 준비 겸 Kotlin 책을 하나 샀다.<br><strong><em>‘Kotlin in Action’</em></strong> 은 Kotlin 언어를 개발한 JetBrains 개발자들이 직접 쓴 책으로, <u>Kotlin 다운 Kotlin 개발</u>을 하기 위해 첫 단추로 택했다.<br>내가 책 읽는 속도는 빠른데 머리에서 휘발되는 속도도 빠른 편이라(…) 시간 날 때 마다 읽은 부분은 차근차근 정리 해두려고 한다. </p>\n<blockquote>\n<p><strong>Kotlin</strong>은 <em>최신 멀티플랫폼 애플리케이션을 위한 정적 타입 언어</em> 로,<br>2017 Google I/O에서 안드로이드 공식언어로 선정되었고 현재 1.3 버전까지 릴리즈 되어있다.</p>\n<p>Kotlin 공식 페이지 <a href=\"https://kotlinlang.org/\" target=\"_blank\" rel=\"noopener\">https://kotlinlang.org/</a></p>\n</blockquote>\n<center><h2>_ _ _</h2></center>\n\n<p><br></p>\n<hr>\n<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><h4 id=\"Java-를-대신할-언어에-대한-Requirement-3가지\"><a href=\"#Java-를-대신할-언어에-대한-Requirement-3가지\" class=\"headerlink\" title=\"Java 를 대신할 언어에 대한 Requirement 3가지\"></a>Java 를 대신할 언어에 대한 Requirement 3가지</h4><ol>\n<li>정적 타입 지정 (static typing)</li>\n<li>기존 자바 코드와의 완전한 호환성</li>\n<li>해당 언어를 위한 도구 개발 복잡성 x</li>\n</ol>\n<p>⇒ 배우고 이해하기 쉬우며 대규모 개발/유지보수성/기존 자바와의 호환성에 적합한 강력한 언어, <u><strong>‘Kotlin’</strong></u></p>\n<p><br></p>\n<h1 id=\"1장-코틀린이란-무엇이며-왜-필요한가\"><a href=\"#1장-코틀린이란-무엇이며-왜-필요한가\" class=\"headerlink\" title=\"1장. 코틀린이란, 무엇이며 왜 필요한가?\"></a>1장. 코틀린이란, 무엇이며 왜 필요한가?</h1><p>Kotlin은 자바 플랫폼에서 돌아가는 새로운 프로그래밍 언어다.<br><strong>간결하고 실용적</strong>이며 <strong>Java 코드와의 상호운용성</strong> (interoperability)을 중시한다.</p>\n<h2 id=\"특성\"><a href=\"#특성\" class=\"headerlink\" title=\"특성\"></a>특성</h2><h4 id=\"1-대상-플랫폼-자바가-실행되는-Everywhere\"><a href=\"#1-대상-플랫폼-자바가-실행되는-Everywhere\" class=\"headerlink\" title=\"1. 대상 플랫폼 : 자바가 실행되는 Everywhere\"></a>1. 대상 플랫폼 : 자바가 실행되는 Everywhere</h4><p>일부가 아닌 개발 과정에서 수행해야하는 모든 과업에 있어 폭넓게 생산성을 향상 시킨다.<br>구체적인 영역 or 특정 프로그램 패러다임을 지원하는 여러 라이브러리와의 융합성 ↑</p>\n<p><br></p>\n<h4 id=\"2-정적-타입-지정-언어\"><a href=\"#2-정적-타입-지정-언어\" class=\"headerlink\" title=\"2. 정적 타입 지정 언어\"></a>2. 정적 타입 지정 언어</h4><p>Kotlin은 <strong>정적 타입 지정 언어</strong> 이면서, <u>type inference</u> (타입추론) 과 <u>nullable type</u>을 지원한다.<br>⇒ 프로그래머의 불편함 해소 &amp; 컴파일 시점에 NPE 여부 검사 가능</p>\n<ul>\n<li><p><strong>정적 타입</strong> (statically typed) 지정 언어 : Java, Kotlin ..</p>\n<blockquote>\n<p>모든 프로그램 구성 요소 타입을 컴파일 시점에 알 수 있고, 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증한다.</p>\n</blockquote>\n<p>  장점 : 성능 / 신뢰성 / 유지 보수성 / 도구 지원 _ <code>p.36</code></p>\n<p>  <br></p>\n</li>\n<li><p><strong>동적 타입</strong> (dynamically typed) 지정 언어 : Groovy, JRuby …</p>\n<blockquote>\n<p>타입과 관계없이 모든 값을 변수에 넣을 수 있고, 필드나 메소드 접근에 대한 검증이 실행 시점에 일어난다. </p>\n</blockquote>\n<p>  동적이 더 유연하고 코드도 짧아지지만, 오류를 사전에 거르지 못하고 Runtime Error 발생 가능성 존재</p>\n</li>\n</ul>\n<p><br></p>\n<h4 id=\"3-함수형-객체지향-프로그래밍\"><a href=\"#3-함수형-객체지향-프로그래밍\" class=\"headerlink\" title=\"3. 함수형 / 객체지향 프로그래밍\"></a>3. 함수형 / 객체지향 프로그래밍</h4><p>Kotlin으로 코드를 작성 할 땐, Java와 같은 <u>객체지향 프로그래밍 (OOP)</u> 과 <u>함수형 프로그래밍</u> 접근 방법을 조합해서 문제에 가장 적합한 도구를 사용하면 된다.</p>\n<blockquote>\n<p><strong>함수형 프로그래밍</strong> 의 핵심 개념</p>\n<ul>\n<li>first-class function (일급 함수)</li>\n<li>immutability</li>\n<li>no side effect _ pure function</li>\n</ul>\n</blockquote>\n<p><br></p>\n<h4 id=\"4-무료-오픈소스\"><a href=\"#4-무료-오픈소스\" class=\"headerlink\" title=\"4. 무료 오픈소스\"></a>4. 무료 오픈소스</h4><p>Kotlin 언어와 이와 관련된 모든 도구는 오픈소스이다.<br>(<a href=\"https://github.com/jetbrains/kotlin\" target=\"_blank\" rel=\"noopener\">https://github.com/jetbrains/kotlin</a> - Apache2 License.)</p>\n<p><br></p>\n<h2 id=\"응용\"><a href=\"#응용\" class=\"headerlink\" title=\"응용\"></a>응용</h2><h4 id=\"코틀린-서버-프로그래밍\"><a href=\"#코틀린-서버-프로그래밍\" class=\"headerlink\" title=\"코틀린 서버 프로그래밍\"></a>코틀린 서버 프로그래밍</h4><blockquote>\n<p><strong>서버 프로그래밍</strong> 의 범위</p>\n<ul>\n<li>브라우저에 HTML 페이지를 반환하는 웹 애플리케이션</li>\n<li>모바일 애플리케이션에게 HTTP를 통해 JSON API를  </li>\n<li>RPC (Remote Procedure Call) 프로토콜을 통해 서로 통신하는 마이크로 서비스</li>\n</ul>\n</blockquote>\n<p>Kotlin은 이러한 애플리케이션 개발에 도움을 주는 기존의 자바 프레임워크나 기술과 매끄럽게 상호운용 가능하다.</p>\n<p>+ 새로운 기술도 적용 가능 (ex. Kotlin의 Builder Pattern, Persistence Framework …)<br>  ⇒ <code>7.5절</code> &amp; <code>11장</code> 에서 좀 더 자세히</p>\n<p><br></p>\n<h4 id=\"코틀린-안드로이드-프로그래밍\"><a href=\"#코틀린-안드로이드-프로그래밍\" class=\"headerlink\" title=\"코틀린 안드로이드 프로그래밍\"></a>코틀린 안드로이드 프로그래밍</h4><p>모바일 애플리케이션은 전형적인 엔터프라이즈 애플리케이션보다 더 작고 기존과 신규 코드 통합 필요성도 더 적고, 다양한 디바이스에 대한 서비스 신뢰성 보장과 빠른 개발&amp;배포가 필요하다.</p>\n<p>Kotlin 언어의 특성과 특별한 컴파일러 플러그인 지원을 조합하면 개발 생산성을 더 높일 수 있다.<br>뿐만 아니라 애플리케이션 신뢰성 향상, 자바6와 완전한 호환, 성능 손실 x 과 같은 장점도 취할 수 있다.</p>\n<p>+ 참조 _ 안드로이드 API에 대한 Kotlin Adaptor를 제공하고 있는 <strong>Anko Library</strong> <a href=\"https://github.com/kotlin/anko\" target=\"_blank\" rel=\"noopener\">https://github.com/kotlin/anko</a></p>\n<p><br></p>\n<h2 id=\"철학\"><a href=\"#철학\" class=\"headerlink\" title=\"철학\"></a>철학</h2><blockquote>\n<p>대개 Kotlin은 Java와의 <strong><em>상호운용성</em></strong> 에 초점을 맞춘 <strong><em>실용적</em></strong> 이고 <strong><em>간결</em></strong> 하며 <strong><em>안전한</em></strong> 언어로 표현된다.</p>\n</blockquote>\n<h4 id=\"실용성\"><a href=\"#실용성\" class=\"headerlink\" title=\"실용성\"></a>실용성</h4><ul>\n<li>연구를 위한 언어가 아닌, 실제 문제를 해결하기 위해 만들어진 실용적인 언어이다.</li>\n<li>특정 프로그래밍 스타일이나 패러다임 사용을 강제하지 않는다.</li>\n<li>도구를 강조한다. (IDE 지원)</li>\n</ul>\n<p><br></p>\n<h4 id=\"간결성\"><a href=\"#간결성\" class=\"headerlink\" title=\"간결성\"></a>간결성</h4><ul>\n<li>기존 코드 이해가 더 쉬워진다. (→ 생산성과 개발 속도 향상)</li>\n<li>부수적인 요소등을 묵시적으로 제공하여 코드가 깔끔하다.</li>\n<li>람다를 지원한다.</li>\n<li>그러나 소스코드를 가능한 짧게 만드는 것이 코틀린의 설계 목표는 아니다.</li>\n</ul>\n<p><br></p>\n<h4 id=\"안전성\"><a href=\"#안전성\" class=\"headerlink\" title=\"안전성\"></a>안전성</h4><p>  프로그램의 안전성과 생산성 사이에는 trade-off 존재</p>\n<ul>\n<li>JVM에서 실행한다. (메모리 안전성과 버퍼 플로우 방지등 기본적으로 높은 안전성 확보)</li>\n<li>정적 타입 지정 언어으로, 애플리케이션의 타입 안전성을 보장한다.</li>\n<li>실행 시점이 아닌 컴파일 시점에 검사를 통해 더 많은 오류를 방지해준다. (ex. <code>NullPointerException</code>, <code>ClassCastException</code>)</li>\n</ul>\n<p><br></p>\n<h4 id=\"상호운용성\"><a href=\"#상호운용성\" class=\"headerlink\" title=\"상호운용성\"></a>상호운용성</h4><ul>\n<li>Java의 기존 라이브러리를 그대로 사용 가능하고, 최대한 활용하고 있다.</li>\n<li>Java ←→ Kotlin 호출에 따로 노력이 필요하지 않다.</li>\n<li>다중 언어 프로젝트를 완전히 지원한다.</li>\n</ul>\n<p><br></p>\n<h2 id=\"코틀린-도구-사용\"><a href=\"#코틀린-도구-사용\" class=\"headerlink\" title=\"코틀린 도구 사용\"></a>코틀린 도구 사용</h2><p>Kotlin도 Java와 마찬가지로 컴파일 언어이다.<br><img src=\"https://user-images.githubusercontent.com/26691216/60521297-f6b43e80-9d21-11e9-956b-4f827ed75f1b.jpg\" alt=\"kotlin-runtime-diagram\"></p>\n<center><i>Kotlin Build Process</i></center>\n\n<p><br></p>\n<h4 id=\"자바-코틀린-변환\"><a href=\"#자바-코틀린-변환\" class=\"headerlink\" title=\"자바-코틀린 변환\"></a>자바-코틀린 변환</h4><p>Intellij IDEA에서는 자바 코드 조각을 코틀린 파일(.kt)에 붙여넣기<br>자바 파일 자체를 변환하려면 <code>Code &gt; Convert Java File to Kotlin File</code> </p>\n<p>도구에 대해서는 필요에 따라 쓰면 되는거라 나머지 내용 생략.</p>\n<p><br></p>\n<h3 id=\"1장-요약-p-57\"><a href=\"#1장-요약-p-57\" class=\"headerlink\" title=\"1장 요약 p.57\"></a>1장 요약 <code>p.57</code></h3>"},{"title":"Kubernetes는 뭘까","date":"2019-01-26T05:38:20.000Z","_content":"\n## Kubernetes를 시작하기 앞서\n\n> *최신 개발 트렌드는 ...*\n>\n> *어플리케이션의 구조를 <u>작고, 독립적인 단위</u>로 개발하고 (Microservices),*\n>\n> *이를 <u>경량화된 가상화 환경</u>에서 구동할 수 있는 단위 (Container)로 생성하여,*\n>\n> *이러한 <u>컨테이너들을 관리</u>할 수 있는 환경 (Cloud Native)을 구성하는 것이다*\n\n<br>\n\n\n### 1. Microservice Architecture (MSA)\n\n과거에는 서비스를 하나의 애플리케이션으로 만들어 모든 시스템을 그 하나에 다 집어넣는 **모놀리식 아키텍처(Monorithic Architecture)** 로 만들었다. 이러한 일체식 구조는 개발/배포/확장을 단순하게 만드는 장점을 가지지만, 큰 규모일 수록 코드이해나 수정이 어렵다.\n\n그래서 등장하게된 **마이크로서비스 아키텍처(Microservice Architecture)** 는 서비스를 <u>작고</u>, <u>독립적이고</u>, <u>느슨하게 결합</u>하는 방식의 서비스 지향 아키텍처이다. 각각의 요소를 독립적인 어플리케이션으로 만들고, API로 조합해 애플리케이션으로 만든다.\n\n> **MSA 구성요소**\n>\n> - Service Discovery\n> - Circuit Breaker\n> - Sidecar (Service Discovery + Circuit Breaker) \n> - Service Mesh\n> - Service Mesh's Control Plane\n\n\n<br>\n\n<br>\n\n### 2. Virtualization\n\n서버를 가상으로 분할하는 **가상화 (Virtualization)** 는, 분할된 가상의 서버 내부에서 서비스를 실행하여 리소스를 효율적으로 쓰고자하는 기술이다. 가상화는 **KVM, XEN, Hyper-V** 등의 하이퍼바이저 기반의 기술과, **Docker, LXC** 등의 컨테이너 기반의 기술이 발전하면서 상용화되고 있다.\n\n<br>\n\n### Container\n\n> **VM** 은 하이퍼바이저를 통한 하드웨어의 가상화이고, \n>\n> **Container** 는 OS레벨의 가상화 (User 공간의 추상화)를 제공한다.\n\n**Container**는 host 시스템의 커널을 container들끼리 공유하기때문에 가볍고 빠른 속도를 가지며 편리하다.\n\n모듈성(modularity)와 확장성(scalability)이 좋지만 보안성이 약하다 => VM과 공존 필요\n\n​\t\t*여러대의 서버에 여러대의 어플리케이션을 쓴다면 VM이,*\n\n​\t\t*하나의 서버에 여러대의 어플리케이션을 쓴다면 Container가 적합할 수 있다*\n\n<br>\n\n### Docker\n\n리눅스 컨테이너를 기반으로 하는 오픈소스 프로젝트\n\nnamespace, control group(cgroup)과 같은 리눅스 커널 기능을 이용해서 OS 위에 컨테이너들을 생성하는 기술이다.\n\n\n<br>\n<br>\n\n\n### 3. Cloud Native Computing Foundation (CNCF)\n\n**Cloud Native Computing** 은 클라우드 컴퓨팅 모델의 장점을 모두 활용하는 애플리케이션을 개발하고 실행하기 위한 접근 방식이다.\n\nmicroservice로 앱을 배포하고, 컨테이너 별로 패키징하고, 리소스 사용량을 최적화하는 동적 조절을위해 오픈소스 소프트웨어를 사용한다. **Cloud Native Computing Foundation (CNCF)** 는 이러한 클라우드 기술과 관련된 표준형을 개발하려는 단체이며, **<u>Kubernetes</u>**가 유일한 중심 프로젝트로 편성되었다.\n\n>  kubernetes, prometheus, envoy, istio, ...\n\n\n<br>\n\n<br>\n\n<br>\n\n\n# Kubernetes (k8s) 란?\n\n> *그래서 MSA형태로 개발된 서비스들을 Docker로 컨테이너화해서 띄우긴했는데..*\n>\n> * 여러대의 물리서버에서 각각 관리하기도 어렵고\n>\n> - <u>lifecycle management</u>도 필요하고 (문제 대응, 패치, 업데이트 등)\n>\n> - 컨테이너 배포, 스케일링, 오퍼레이팅등도 자동으로 되면 좋겠는데...\n>\n>   => (\"해결사가 왔어!\") **Kubernetes**\n\n<br>\n\n\n### Kubernetes\n\n**kubernetes**는 \"Docker container Orchestration tool\" \n\n컨테이너화된 어플리케이션을 Automatic deployment / Scaling / Management\n\n\\- 그리스어로 '키잡이'라는 뜻으로, 줄여서 k8s라고 부른다. (k와 s사이에 8글자)\n\n\\- Google에서 최초 개발되었고 현재는 CNCF에 기증된 상태\n\n> *service를 host os를 공유하는 container화해서 올리는  **docker***\n>\n> *docker를 관리하는 **k8s**  (kubernetes)* \n>\n> *이러한 k8s application들을 chart화 시키고 관리하는 **helm***\n\n\n<br>\n\n\n### k8s Object\n\n*  **Pod** (name + spec + containers)\n\n\\- k8s의 가장 기본단위이자 Container의 묶음\n\n\\- pod 단위로 network namespace와 ip 가질 수 있음 (!= namespace in k8s)\n\n\\- 같은 pod에서는 같은 volume 접근가능\n\n<br>\n\n* **ReplicaSet** (**Pod** + replicas)\n\n\\- <u>replica</u>는 복제라는 의미로 replicas 수만큼 pod가 유지되도록 관리된다\n\n\\- pod는 죽으면 다시 되살리지않지만, ReplicaSet으로 만들면 replicas 수 (=pod 수)에 맞게 계속 살린다\n\n\\- (단, 모니터링이 되어 autoscaler가 작동되고 있는 상황이어야 함)\n\n<br>\n\n* **Deployment** (**ReplicasSet** + History (revision))\n\n\\- deployment는 name + replicas + pod 내용으로 구성되고, 대부분은 deployment를 사용해서 배포한다\n\n\\- 버전별로 설치/롤백되고 배포 관리가 가능하다\n\n\\- apps/v1일때는 <u>selector</u>가 있어야 <u>labels</u>를 가져올 수 있다\n\n\n\n> ​\t`kubectl create deployment.yaml` *로 Deployment를 생성할 때 순서를 확인해보면 ,*\n>\n> ​\t*\" Deployment -> ReplicaSet -> Pod \"  순으로 생성된다*\n\n\n<br>\n\n* **Service**\n\nLoad balancer를 이용하여 여러 pod들을 하나의 ip, port로 묶어서 제공하는 DNS이다\n\n그 기준은 <u>label selector</u> 로, 특정 label을 가진 것들을 하나의 서비스로 묶는다.\n\n> Service object 노출 방식 3가지\n>\n> 1. **ClusterIP** - default값으로, Service에 Cluster IP (내부 IP)를 할당한다. 클러스터 내부에서만 접근 가능하고 외부에서는 접근이 불가능\n> 2. **NodePort** - 각각의 Node의 IP와 static 포트를 노출하여 접근가능하게 하고, 클러스터 외부에서도 접근가능\n> 3. **Load Balancer** - Cloud provider(GCE/AWS)와 같은 외부IP를 가진 Load balancer에게 Service를 노출\n\n\n<br>\n\n* 그 외 고오급 오브젝트\n\n\\- **DaemonSet** : 맵핑된 label이 있는 node가 추가되면 자동으로 해당 node에 pod 생성을 보장 (scaling)\n\n\\- **StatefulSet** : 컨테이너가 제거/재시작되어도 상태의 영속성과 지속성을 보장\t=> like DB\n<br>\n\n> \\- **Affinity** : kube-schedular에게 정보 제공. 부하 분산 또는 버전관리 가능\n>\n> ( Session **Affinity** - sticky session 제공 (canary deployment) )\n\n\n<br>\n<br>\n\n\n### 기타 Keyword\n\n**Docker 배포**\n\n> 특징 : 확장성, 표준성, 이미지 기반, 환경변수로 제어하는 설정, 공유자원..\n\n배포툴 : <u>**kubernetes**</u>, docker swarm, coreos, fleet,...\n\n\n<br>\n\n**Kubernetes 배포 프로세스**\n\n> *binary build -> containerizing(image) -> push image -> service define -> test deploy (canary test) -> prod deploy*  \n>\n> => 어렵고 복잡. 이런 배포 프로세스를 통합/자동화하는 CICD (배포툴) 필요!\n\n배포툴 : <u>kubespray</u>, kubeadm, kops, ... (CaaS 지원)\n\n\n<br>\n<br>\n\n\\* **오케스트레이션** (Orchestration)\n\n여러 서버를 운영할때, 이들을 관리하는 것\n\n- IaC를 돕는 설정관련 도구는 chef puppet <u>Ansible</u> SaltStack…\n\n- CI/CD 관리 도구는 Travis CI, <u>Jenkins</u>, Circle CI ..\n\n- 컨테이너관리 도구는 Docker swarm, <u>Kubernetes</u> …\n\n<br>\n\n\\* **Ansible**\n\n구성관리 tool로, 인프라 관리과정을 코드로 기술한 IaC (Infra as Code)를 효율적이고 자동으로 관리할수있는 인프라 도구.\n\nPython 기반의 개발 + YAML로 정의 + JSON으로 통신\n\n초기설정이나 모니터링, 변경사항 추적이 불가능하다는 단점이 있지만, shell command를 제외하고는 모두 **Idempotency(멱등성)** 을 제공한다.\n\n>  *kubespray는 ansible 기반의 배포툴이다.*\n\n<br>\n\n\n\\* **Helm**\n\nChart라는 개념으로 kubernetes의 application을 정의, 배포하고 관리\n\n- Chart: app 구성하는 Kubernetes 객체들을 정의한 manifest template파일 및 설정묶음\n- Cient (helm client, CLI) - Server (**tiller**, pod형태로 배포됨) 구조\n- Release: client 통해 kube 위에 배포된 app\n\n=> helm client 설치 후 tiller server를 kubernetes cluster위에 설치해야함\n\n```\nhelm init (—upgrade)\t// tiller 설치 \nhelm install \t\t\t// repository에 등록된 chart를 client->tiller로 보냄\nhelm lint\t\t\t\t// chart의 문법검사\n```\n\n<br>\n\n\\* **CI/CD**\n\n- CI (Continuous Integration): 지속적 통합, 자주 Build & Packaging\n\n- CD (Continous Delivery / Deployment): 지속적 배포, 자주 Deployment\n\n<br>\n<br>\n\n\n### 참조\n\n1. https://www.samsungsds.com/global/ko/support/insights/101917_RD_Cloudnative.html)\n2. https://engineering.linecorp.com/ko/blog/infrastructure-trends-open-infra-days-korea-2018/\n3. 갓승규님 블로그 https://ahnseungkyu.com/ \n4. Google Cloud - JAM k8s 입문반 QWIK LAB 진행\n","source":"_posts/Kubernetes는-뭘까.md","raw":"---\ntitle: Kubernetes는 뭘까\ndate: 2019-01-26 14:38:20 \ncategories: kubernetes\ntags: \n  - kubernetes\n  - k8s\n  - container\n  - CNCF\n---\n\n## Kubernetes를 시작하기 앞서\n\n> *최신 개발 트렌드는 ...*\n>\n> *어플리케이션의 구조를 <u>작고, 독립적인 단위</u>로 개발하고 (Microservices),*\n>\n> *이를 <u>경량화된 가상화 환경</u>에서 구동할 수 있는 단위 (Container)로 생성하여,*\n>\n> *이러한 <u>컨테이너들을 관리</u>할 수 있는 환경 (Cloud Native)을 구성하는 것이다*\n\n<br>\n\n\n### 1. Microservice Architecture (MSA)\n\n과거에는 서비스를 하나의 애플리케이션으로 만들어 모든 시스템을 그 하나에 다 집어넣는 **모놀리식 아키텍처(Monorithic Architecture)** 로 만들었다. 이러한 일체식 구조는 개발/배포/확장을 단순하게 만드는 장점을 가지지만, 큰 규모일 수록 코드이해나 수정이 어렵다.\n\n그래서 등장하게된 **마이크로서비스 아키텍처(Microservice Architecture)** 는 서비스를 <u>작고</u>, <u>독립적이고</u>, <u>느슨하게 결합</u>하는 방식의 서비스 지향 아키텍처이다. 각각의 요소를 독립적인 어플리케이션으로 만들고, API로 조합해 애플리케이션으로 만든다.\n\n> **MSA 구성요소**\n>\n> - Service Discovery\n> - Circuit Breaker\n> - Sidecar (Service Discovery + Circuit Breaker) \n> - Service Mesh\n> - Service Mesh's Control Plane\n\n\n<br>\n\n<br>\n\n### 2. Virtualization\n\n서버를 가상으로 분할하는 **가상화 (Virtualization)** 는, 분할된 가상의 서버 내부에서 서비스를 실행하여 리소스를 효율적으로 쓰고자하는 기술이다. 가상화는 **KVM, XEN, Hyper-V** 등의 하이퍼바이저 기반의 기술과, **Docker, LXC** 등의 컨테이너 기반의 기술이 발전하면서 상용화되고 있다.\n\n<br>\n\n### Container\n\n> **VM** 은 하이퍼바이저를 통한 하드웨어의 가상화이고, \n>\n> **Container** 는 OS레벨의 가상화 (User 공간의 추상화)를 제공한다.\n\n**Container**는 host 시스템의 커널을 container들끼리 공유하기때문에 가볍고 빠른 속도를 가지며 편리하다.\n\n모듈성(modularity)와 확장성(scalability)이 좋지만 보안성이 약하다 => VM과 공존 필요\n\n​\t\t*여러대의 서버에 여러대의 어플리케이션을 쓴다면 VM이,*\n\n​\t\t*하나의 서버에 여러대의 어플리케이션을 쓴다면 Container가 적합할 수 있다*\n\n<br>\n\n### Docker\n\n리눅스 컨테이너를 기반으로 하는 오픈소스 프로젝트\n\nnamespace, control group(cgroup)과 같은 리눅스 커널 기능을 이용해서 OS 위에 컨테이너들을 생성하는 기술이다.\n\n\n<br>\n<br>\n\n\n### 3. Cloud Native Computing Foundation (CNCF)\n\n**Cloud Native Computing** 은 클라우드 컴퓨팅 모델의 장점을 모두 활용하는 애플리케이션을 개발하고 실행하기 위한 접근 방식이다.\n\nmicroservice로 앱을 배포하고, 컨테이너 별로 패키징하고, 리소스 사용량을 최적화하는 동적 조절을위해 오픈소스 소프트웨어를 사용한다. **Cloud Native Computing Foundation (CNCF)** 는 이러한 클라우드 기술과 관련된 표준형을 개발하려는 단체이며, **<u>Kubernetes</u>**가 유일한 중심 프로젝트로 편성되었다.\n\n>  kubernetes, prometheus, envoy, istio, ...\n\n\n<br>\n\n<br>\n\n<br>\n\n\n# Kubernetes (k8s) 란?\n\n> *그래서 MSA형태로 개발된 서비스들을 Docker로 컨테이너화해서 띄우긴했는데..*\n>\n> * 여러대의 물리서버에서 각각 관리하기도 어렵고\n>\n> - <u>lifecycle management</u>도 필요하고 (문제 대응, 패치, 업데이트 등)\n>\n> - 컨테이너 배포, 스케일링, 오퍼레이팅등도 자동으로 되면 좋겠는데...\n>\n>   => (\"해결사가 왔어!\") **Kubernetes**\n\n<br>\n\n\n### Kubernetes\n\n**kubernetes**는 \"Docker container Orchestration tool\" \n\n컨테이너화된 어플리케이션을 Automatic deployment / Scaling / Management\n\n\\- 그리스어로 '키잡이'라는 뜻으로, 줄여서 k8s라고 부른다. (k와 s사이에 8글자)\n\n\\- Google에서 최초 개발되었고 현재는 CNCF에 기증된 상태\n\n> *service를 host os를 공유하는 container화해서 올리는  **docker***\n>\n> *docker를 관리하는 **k8s**  (kubernetes)* \n>\n> *이러한 k8s application들을 chart화 시키고 관리하는 **helm***\n\n\n<br>\n\n\n### k8s Object\n\n*  **Pod** (name + spec + containers)\n\n\\- k8s의 가장 기본단위이자 Container의 묶음\n\n\\- pod 단위로 network namespace와 ip 가질 수 있음 (!= namespace in k8s)\n\n\\- 같은 pod에서는 같은 volume 접근가능\n\n<br>\n\n* **ReplicaSet** (**Pod** + replicas)\n\n\\- <u>replica</u>는 복제라는 의미로 replicas 수만큼 pod가 유지되도록 관리된다\n\n\\- pod는 죽으면 다시 되살리지않지만, ReplicaSet으로 만들면 replicas 수 (=pod 수)에 맞게 계속 살린다\n\n\\- (단, 모니터링이 되어 autoscaler가 작동되고 있는 상황이어야 함)\n\n<br>\n\n* **Deployment** (**ReplicasSet** + History (revision))\n\n\\- deployment는 name + replicas + pod 내용으로 구성되고, 대부분은 deployment를 사용해서 배포한다\n\n\\- 버전별로 설치/롤백되고 배포 관리가 가능하다\n\n\\- apps/v1일때는 <u>selector</u>가 있어야 <u>labels</u>를 가져올 수 있다\n\n\n\n> ​\t`kubectl create deployment.yaml` *로 Deployment를 생성할 때 순서를 확인해보면 ,*\n>\n> ​\t*\" Deployment -> ReplicaSet -> Pod \"  순으로 생성된다*\n\n\n<br>\n\n* **Service**\n\nLoad balancer를 이용하여 여러 pod들을 하나의 ip, port로 묶어서 제공하는 DNS이다\n\n그 기준은 <u>label selector</u> 로, 특정 label을 가진 것들을 하나의 서비스로 묶는다.\n\n> Service object 노출 방식 3가지\n>\n> 1. **ClusterIP** - default값으로, Service에 Cluster IP (내부 IP)를 할당한다. 클러스터 내부에서만 접근 가능하고 외부에서는 접근이 불가능\n> 2. **NodePort** - 각각의 Node의 IP와 static 포트를 노출하여 접근가능하게 하고, 클러스터 외부에서도 접근가능\n> 3. **Load Balancer** - Cloud provider(GCE/AWS)와 같은 외부IP를 가진 Load balancer에게 Service를 노출\n\n\n<br>\n\n* 그 외 고오급 오브젝트\n\n\\- **DaemonSet** : 맵핑된 label이 있는 node가 추가되면 자동으로 해당 node에 pod 생성을 보장 (scaling)\n\n\\- **StatefulSet** : 컨테이너가 제거/재시작되어도 상태의 영속성과 지속성을 보장\t=> like DB\n<br>\n\n> \\- **Affinity** : kube-schedular에게 정보 제공. 부하 분산 또는 버전관리 가능\n>\n> ( Session **Affinity** - sticky session 제공 (canary deployment) )\n\n\n<br>\n<br>\n\n\n### 기타 Keyword\n\n**Docker 배포**\n\n> 특징 : 확장성, 표준성, 이미지 기반, 환경변수로 제어하는 설정, 공유자원..\n\n배포툴 : <u>**kubernetes**</u>, docker swarm, coreos, fleet,...\n\n\n<br>\n\n**Kubernetes 배포 프로세스**\n\n> *binary build -> containerizing(image) -> push image -> service define -> test deploy (canary test) -> prod deploy*  \n>\n> => 어렵고 복잡. 이런 배포 프로세스를 통합/자동화하는 CICD (배포툴) 필요!\n\n배포툴 : <u>kubespray</u>, kubeadm, kops, ... (CaaS 지원)\n\n\n<br>\n<br>\n\n\\* **오케스트레이션** (Orchestration)\n\n여러 서버를 운영할때, 이들을 관리하는 것\n\n- IaC를 돕는 설정관련 도구는 chef puppet <u>Ansible</u> SaltStack…\n\n- CI/CD 관리 도구는 Travis CI, <u>Jenkins</u>, Circle CI ..\n\n- 컨테이너관리 도구는 Docker swarm, <u>Kubernetes</u> …\n\n<br>\n\n\\* **Ansible**\n\n구성관리 tool로, 인프라 관리과정을 코드로 기술한 IaC (Infra as Code)를 효율적이고 자동으로 관리할수있는 인프라 도구.\n\nPython 기반의 개발 + YAML로 정의 + JSON으로 통신\n\n초기설정이나 모니터링, 변경사항 추적이 불가능하다는 단점이 있지만, shell command를 제외하고는 모두 **Idempotency(멱등성)** 을 제공한다.\n\n>  *kubespray는 ansible 기반의 배포툴이다.*\n\n<br>\n\n\n\\* **Helm**\n\nChart라는 개념으로 kubernetes의 application을 정의, 배포하고 관리\n\n- Chart: app 구성하는 Kubernetes 객체들을 정의한 manifest template파일 및 설정묶음\n- Cient (helm client, CLI) - Server (**tiller**, pod형태로 배포됨) 구조\n- Release: client 통해 kube 위에 배포된 app\n\n=> helm client 설치 후 tiller server를 kubernetes cluster위에 설치해야함\n\n```\nhelm init (—upgrade)\t// tiller 설치 \nhelm install \t\t\t// repository에 등록된 chart를 client->tiller로 보냄\nhelm lint\t\t\t\t// chart의 문법검사\n```\n\n<br>\n\n\\* **CI/CD**\n\n- CI (Continuous Integration): 지속적 통합, 자주 Build & Packaging\n\n- CD (Continous Delivery / Deployment): 지속적 배포, 자주 Deployment\n\n<br>\n<br>\n\n\n### 참조\n\n1. https://www.samsungsds.com/global/ko/support/insights/101917_RD_Cloudnative.html)\n2. https://engineering.linecorp.com/ko/blog/infrastructure-trends-open-infra-days-korea-2018/\n3. 갓승규님 블로그 https://ahnseungkyu.com/ \n4. Google Cloud - JAM k8s 입문반 QWIK LAB 진행\n","slug":"Kubernetes는-뭘까","published":1,"updated":"2019-06-30T07:18:36.517Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxlyibcv000c1n4yuj8d9ci8","content":"<h2 id=\"Kubernetes를-시작하기-앞서\"><a href=\"#Kubernetes를-시작하기-앞서\" class=\"headerlink\" title=\"Kubernetes를 시작하기 앞서\"></a>Kubernetes를 시작하기 앞서</h2><blockquote>\n<p><em>최신 개발 트렌드는 …</em></p>\n<p><em>어플리케이션의 구조를 <u>작고, 독립적인 단위</u>로 개발하고 (Microservices),</em></p>\n<p><em>이를 <u>경량화된 가상화 환경</u>에서 구동할 수 있는 단위 (Container)로 생성하여,</em></p>\n<p><em>이러한 <u>컨테이너들을 관리</u>할 수 있는 환경 (Cloud Native)을 구성하는 것이다</em></p>\n</blockquote>\n<p><br></p>\n<h3 id=\"1-Microservice-Architecture-MSA\"><a href=\"#1-Microservice-Architecture-MSA\" class=\"headerlink\" title=\"1. Microservice Architecture (MSA)\"></a>1. Microservice Architecture (MSA)</h3><p>과거에는 서비스를 하나의 애플리케이션으로 만들어 모든 시스템을 그 하나에 다 집어넣는 <strong>모놀리식 아키텍처(Monorithic Architecture)</strong> 로 만들었다. 이러한 일체식 구조는 개발/배포/확장을 단순하게 만드는 장점을 가지지만, 큰 규모일 수록 코드이해나 수정이 어렵다.</p>\n<p>그래서 등장하게된 <strong>마이크로서비스 아키텍처(Microservice Architecture)</strong> 는 서비스를 <u>작고</u>, <u>독립적이고</u>, <u>느슨하게 결합</u>하는 방식의 서비스 지향 아키텍처이다. 각각의 요소를 독립적인 어플리케이션으로 만들고, API로 조합해 애플리케이션으로 만든다.</p>\n<blockquote>\n<p><strong>MSA 구성요소</strong></p>\n<ul>\n<li>Service Discovery</li>\n<li>Circuit Breaker</li>\n<li>Sidecar (Service Discovery + Circuit Breaker) </li>\n<li>Service Mesh</li>\n<li>Service Mesh’s Control Plane</li>\n</ul>\n</blockquote>\n<p><br></p>\n<p><br></p>\n<h3 id=\"2-Virtualization\"><a href=\"#2-Virtualization\" class=\"headerlink\" title=\"2. Virtualization\"></a>2. Virtualization</h3><p>서버를 가상으로 분할하는 <strong>가상화 (Virtualization)</strong> 는, 분할된 가상의 서버 내부에서 서비스를 실행하여 리소스를 효율적으로 쓰고자하는 기술이다. 가상화는 <strong>KVM, XEN, Hyper-V</strong> 등의 하이퍼바이저 기반의 기술과, <strong>Docker, LXC</strong> 등의 컨테이너 기반의 기술이 발전하면서 상용화되고 있다.</p>\n<p><br></p>\n<h3 id=\"Container\"><a href=\"#Container\" class=\"headerlink\" title=\"Container\"></a>Container</h3><blockquote>\n<p><strong>VM</strong> 은 하이퍼바이저를 통한 하드웨어의 가상화이고, </p>\n<p><strong>Container</strong> 는 OS레벨의 가상화 (User 공간의 추상화)를 제공한다.</p>\n</blockquote>\n<p><strong>Container</strong>는 host 시스템의 커널을 container들끼리 공유하기때문에 가볍고 빠른 속도를 가지며 편리하다.</p>\n<p>모듈성(modularity)와 확장성(scalability)이 좋지만 보안성이 약하다 =&gt; VM과 공존 필요</p>\n<p>​        <em>여러대의 서버에 여러대의 어플리케이션을 쓴다면 VM이,</em></p>\n<p>​        <em>하나의 서버에 여러대의 어플리케이션을 쓴다면 Container가 적합할 수 있다</em></p>\n<p><br></p>\n<h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><p>리눅스 컨테이너를 기반으로 하는 오픈소스 프로젝트</p>\n<p>namespace, control group(cgroup)과 같은 리눅스 커널 기능을 이용해서 OS 위에 컨테이너들을 생성하는 기술이다.</p>\n<p><br><br><br></p>\n<h3 id=\"3-Cloud-Native-Computing-Foundation-CNCF\"><a href=\"#3-Cloud-Native-Computing-Foundation-CNCF\" class=\"headerlink\" title=\"3. Cloud Native Computing Foundation (CNCF)\"></a>3. Cloud Native Computing Foundation (CNCF)</h3><p><strong>Cloud Native Computing</strong> 은 클라우드 컴퓨팅 모델의 장점을 모두 활용하는 애플리케이션을 개발하고 실행하기 위한 접근 방식이다.</p>\n<p>microservice로 앱을 배포하고, 컨테이너 별로 패키징하고, 리소스 사용량을 최적화하는 동적 조절을위해 오픈소스 소프트웨어를 사용한다. <strong>Cloud Native Computing Foundation (CNCF)</strong> 는 이러한 클라우드 기술과 관련된 표준형을 개발하려는 단체이며, <strong><u>Kubernetes</u></strong>가 유일한 중심 프로젝트로 편성되었다.</p>\n<blockquote>\n<p> kubernetes, prometheus, envoy, istio, …</p>\n</blockquote>\n<p><br></p>\n<p><br></p>\n<p><br></p>\n<h1 id=\"Kubernetes-k8s-란\"><a href=\"#Kubernetes-k8s-란\" class=\"headerlink\" title=\"Kubernetes (k8s) 란?\"></a>Kubernetes (k8s) 란?</h1><blockquote>\n<p><em>그래서 MSA형태로 개발된 서비스들을 Docker로 컨테이너화해서 띄우긴했는데..</em></p>\n<ul>\n<li>여러대의 물리서버에서 각각 관리하기도 어렵고</li>\n</ul>\n<ul>\n<li><p><u>lifecycle management</u>도 필요하고 (문제 대응, 패치, 업데이트 등)</p>\n</li>\n<li><p>컨테이너 배포, 스케일링, 오퍼레이팅등도 자동으로 되면 좋겠는데…</p>\n<p>=&gt; (“해결사가 왔어!”) <strong>Kubernetes</strong></p>\n</li>\n</ul>\n</blockquote>\n<p><br></p>\n<h3 id=\"Kubernetes\"><a href=\"#Kubernetes\" class=\"headerlink\" title=\"Kubernetes\"></a>Kubernetes</h3><p><strong>kubernetes</strong>는 “Docker container Orchestration tool” </p>\n<p>컨테이너화된 어플리케이션을 Automatic deployment / Scaling / Management</p>\n<p>- 그리스어로 ‘키잡이’라는 뜻으로, 줄여서 k8s라고 부른다. (k와 s사이에 8글자)</p>\n<p>- Google에서 최초 개발되었고 현재는 CNCF에 기증된 상태</p>\n<blockquote>\n<p><em>service를 host os를 공유하는 container화해서 올리는  <strong>docker</strong></em></p>\n<p><em>docker를 관리하는 <strong>k8s</strong>  (kubernetes)</em> </p>\n<p><em>이러한 k8s application들을 chart화 시키고 관리하는 <strong>helm</strong></em></p>\n</blockquote>\n<p><br></p>\n<h3 id=\"k8s-Object\"><a href=\"#k8s-Object\" class=\"headerlink\" title=\"k8s Object\"></a>k8s Object</h3><ul>\n<li><strong>Pod</strong> (name + spec + containers)</li>\n</ul>\n<p>- k8s의 가장 기본단위이자 Container의 묶음</p>\n<p>- pod 단위로 network namespace와 ip 가질 수 있음 (!= namespace in k8s)</p>\n<p>- 같은 pod에서는 같은 volume 접근가능</p>\n<p><br></p>\n<ul>\n<li><strong>ReplicaSet</strong> (<strong>Pod</strong> + replicas)</li>\n</ul>\n<p>- <u>replica</u>는 복제라는 의미로 replicas 수만큼 pod가 유지되도록 관리된다</p>\n<p>- pod는 죽으면 다시 되살리지않지만, ReplicaSet으로 만들면 replicas 수 (=pod 수)에 맞게 계속 살린다</p>\n<p>- (단, 모니터링이 되어 autoscaler가 작동되고 있는 상황이어야 함)</p>\n<p><br></p>\n<ul>\n<li><strong>Deployment</strong> (<strong>ReplicasSet</strong> + History (revision))</li>\n</ul>\n<p>- deployment는 name + replicas + pod 내용으로 구성되고, 대부분은 deployment를 사용해서 배포한다</p>\n<p>- 버전별로 설치/롤백되고 배포 관리가 가능하다</p>\n<p>- apps/v1일때는 <u>selector</u>가 있어야 <u>labels</u>를 가져올 수 있다</p>\n<blockquote>\n<p>​    <code>kubectl create deployment.yaml</code> <em>로 Deployment를 생성할 때 순서를 확인해보면 ,</em></p>\n<p>​    <em>“ Deployment -&gt; ReplicaSet -&gt; Pod “  순으로 생성된다</em></p>\n</blockquote>\n<p><br></p>\n<ul>\n<li><strong>Service</strong></li>\n</ul>\n<p>Load balancer를 이용하여 여러 pod들을 하나의 ip, port로 묶어서 제공하는 DNS이다</p>\n<p>그 기준은 <u>label selector</u> 로, 특정 label을 가진 것들을 하나의 서비스로 묶는다.</p>\n<blockquote>\n<p>Service object 노출 방식 3가지</p>\n<ol>\n<li><strong>ClusterIP</strong> - default값으로, Service에 Cluster IP (내부 IP)를 할당한다. 클러스터 내부에서만 접근 가능하고 외부에서는 접근이 불가능</li>\n<li><strong>NodePort</strong> - 각각의 Node의 IP와 static 포트를 노출하여 접근가능하게 하고, 클러스터 외부에서도 접근가능</li>\n<li><strong>Load Balancer</strong> - Cloud provider(GCE/AWS)와 같은 외부IP를 가진 Load balancer에게 Service를 노출</li>\n</ol>\n</blockquote>\n<p><br></p>\n<ul>\n<li>그 외 고오급 오브젝트</li>\n</ul>\n<p>- <strong>DaemonSet</strong> : 맵핑된 label이 있는 node가 추가되면 자동으로 해당 node에 pod 생성을 보장 (scaling)</p>\n<p>- <strong>StatefulSet</strong> : 컨테이너가 제거/재시작되어도 상태의 영속성과 지속성을 보장    =&gt; like DB<br><br></p>\n<blockquote>\n<p>- <strong>Affinity</strong> : kube-schedular에게 정보 제공. 부하 분산 또는 버전관리 가능</p>\n<p>( Session <strong>Affinity</strong> - sticky session 제공 (canary deployment) )</p>\n</blockquote>\n<p><br><br><br></p>\n<h3 id=\"기타-Keyword\"><a href=\"#기타-Keyword\" class=\"headerlink\" title=\"기타 Keyword\"></a>기타 Keyword</h3><p><strong>Docker 배포</strong></p>\n<blockquote>\n<p>특징 : 확장성, 표준성, 이미지 기반, 환경변수로 제어하는 설정, 공유자원..</p>\n</blockquote>\n<p>배포툴 : <u><strong>kubernetes</strong></u>, docker swarm, coreos, fleet,…</p>\n<p><br></p>\n<p><strong>Kubernetes 배포 프로세스</strong></p>\n<blockquote>\n<p><em>binary build -&gt; containerizing(image) -&gt; push image -&gt; service define -&gt; test deploy (canary test) -&gt; prod deploy</em>  </p>\n<p>=&gt; 어렵고 복잡. 이런 배포 프로세스를 통합/자동화하는 CICD (배포툴) 필요!</p>\n</blockquote>\n<p>배포툴 : <u>kubespray</u>, kubeadm, kops, … (CaaS 지원)</p>\n<p><br><br><br></p>\n<p>* <strong>오케스트레이션</strong> (Orchestration)</p>\n<p>여러 서버를 운영할때, 이들을 관리하는 것</p>\n<ul>\n<li><p>IaC를 돕는 설정관련 도구는 chef puppet <u>Ansible</u> SaltStack…</p>\n</li>\n<li><p>CI/CD 관리 도구는 Travis CI, <u>Jenkins</u>, Circle CI ..</p>\n</li>\n<li><p>컨테이너관리 도구는 Docker swarm, <u>Kubernetes</u> …</p>\n</li>\n</ul>\n<p><br></p>\n<p>* <strong>Ansible</strong></p>\n<p>구성관리 tool로, 인프라 관리과정을 코드로 기술한 IaC (Infra as Code)를 효율적이고 자동으로 관리할수있는 인프라 도구.</p>\n<p>Python 기반의 개발 + YAML로 정의 + JSON으로 통신</p>\n<p>초기설정이나 모니터링, 변경사항 추적이 불가능하다는 단점이 있지만, shell command를 제외하고는 모두 <strong>Idempotency(멱등성)</strong> 을 제공한다.</p>\n<blockquote>\n<p> <em>kubespray는 ansible 기반의 배포툴이다.</em></p>\n</blockquote>\n<p><br></p>\n<p>* <strong>Helm</strong></p>\n<p>Chart라는 개념으로 kubernetes의 application을 정의, 배포하고 관리</p>\n<ul>\n<li>Chart: app 구성하는 Kubernetes 객체들을 정의한 manifest template파일 및 설정묶음</li>\n<li>Cient (helm client, CLI) - Server (<strong>tiller</strong>, pod형태로 배포됨) 구조</li>\n<li>Release: client 통해 kube 위에 배포된 app</li>\n</ul>\n<p>=&gt; helm client 설치 후 tiller server를 kubernetes cluster위에 설치해야함</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm init (—upgrade)\t// tiller 설치 </span><br><span class=\"line\">helm install \t\t\t// repository에 등록된 chart를 client-&gt;tiller로 보냄</span><br><span class=\"line\">helm lint\t\t\t\t// chart의 문법검사</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<p>* <strong>CI/CD</strong></p>\n<ul>\n<li><p>CI (Continuous Integration): 지속적 통합, 자주 Build &amp; Packaging</p>\n</li>\n<li><p>CD (Continous Delivery / Deployment): 지속적 배포, 자주 Deployment</p>\n</li>\n</ul>\n<p><br><br><br></p>\n<h3 id=\"참조\"><a href=\"#참조\" class=\"headerlink\" title=\"참조\"></a>참조</h3><ol>\n<li><a href=\"https://www.samsungsds.com/global/ko/support/insights/101917_RD_Cloudnative.html\" target=\"_blank\" rel=\"noopener\">https://www.samsungsds.com/global/ko/support/insights/101917_RD_Cloudnative.html</a>)</li>\n<li><a href=\"https://engineering.linecorp.com/ko/blog/infrastructure-trends-open-infra-days-korea-2018/\" target=\"_blank\" rel=\"noopener\">https://engineering.linecorp.com/ko/blog/infrastructure-trends-open-infra-days-korea-2018/</a></li>\n<li>갓승규님 블로그 <a href=\"https://ahnseungkyu.com/\" target=\"_blank\" rel=\"noopener\">https://ahnseungkyu.com/</a> </li>\n<li>Google Cloud - JAM k8s 입문반 QWIK LAB 진행</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Kubernetes를-시작하기-앞서\"><a href=\"#Kubernetes를-시작하기-앞서\" class=\"headerlink\" title=\"Kubernetes를 시작하기 앞서\"></a>Kubernetes를 시작하기 앞서</h2><blockquote>\n<p><em>최신 개발 트렌드는 …</em></p>\n<p><em>어플리케이션의 구조를 <u>작고, 독립적인 단위</u>로 개발하고 (Microservices),</em></p>\n<p><em>이를 <u>경량화된 가상화 환경</u>에서 구동할 수 있는 단위 (Container)로 생성하여,</em></p>\n<p><em>이러한 <u>컨테이너들을 관리</u>할 수 있는 환경 (Cloud Native)을 구성하는 것이다</em></p>\n</blockquote>\n<p><br></p>\n<h3 id=\"1-Microservice-Architecture-MSA\"><a href=\"#1-Microservice-Architecture-MSA\" class=\"headerlink\" title=\"1. Microservice Architecture (MSA)\"></a>1. Microservice Architecture (MSA)</h3><p>과거에는 서비스를 하나의 애플리케이션으로 만들어 모든 시스템을 그 하나에 다 집어넣는 <strong>모놀리식 아키텍처(Monorithic Architecture)</strong> 로 만들었다. 이러한 일체식 구조는 개발/배포/확장을 단순하게 만드는 장점을 가지지만, 큰 규모일 수록 코드이해나 수정이 어렵다.</p>\n<p>그래서 등장하게된 <strong>마이크로서비스 아키텍처(Microservice Architecture)</strong> 는 서비스를 <u>작고</u>, <u>독립적이고</u>, <u>느슨하게 결합</u>하는 방식의 서비스 지향 아키텍처이다. 각각의 요소를 독립적인 어플리케이션으로 만들고, API로 조합해 애플리케이션으로 만든다.</p>\n<blockquote>\n<p><strong>MSA 구성요소</strong></p>\n<ul>\n<li>Service Discovery</li>\n<li>Circuit Breaker</li>\n<li>Sidecar (Service Discovery + Circuit Breaker) </li>\n<li>Service Mesh</li>\n<li>Service Mesh’s Control Plane</li>\n</ul>\n</blockquote>\n<p><br></p>\n<p><br></p>\n<h3 id=\"2-Virtualization\"><a href=\"#2-Virtualization\" class=\"headerlink\" title=\"2. Virtualization\"></a>2. Virtualization</h3><p>서버를 가상으로 분할하는 <strong>가상화 (Virtualization)</strong> 는, 분할된 가상의 서버 내부에서 서비스를 실행하여 리소스를 효율적으로 쓰고자하는 기술이다. 가상화는 <strong>KVM, XEN, Hyper-V</strong> 등의 하이퍼바이저 기반의 기술과, <strong>Docker, LXC</strong> 등의 컨테이너 기반의 기술이 발전하면서 상용화되고 있다.</p>\n<p><br></p>\n<h3 id=\"Container\"><a href=\"#Container\" class=\"headerlink\" title=\"Container\"></a>Container</h3><blockquote>\n<p><strong>VM</strong> 은 하이퍼바이저를 통한 하드웨어의 가상화이고, </p>\n<p><strong>Container</strong> 는 OS레벨의 가상화 (User 공간의 추상화)를 제공한다.</p>\n</blockquote>\n<p><strong>Container</strong>는 host 시스템의 커널을 container들끼리 공유하기때문에 가볍고 빠른 속도를 가지며 편리하다.</p>\n<p>모듈성(modularity)와 확장성(scalability)이 좋지만 보안성이 약하다 =&gt; VM과 공존 필요</p>\n<p>​        <em>여러대의 서버에 여러대의 어플리케이션을 쓴다면 VM이,</em></p>\n<p>​        <em>하나의 서버에 여러대의 어플리케이션을 쓴다면 Container가 적합할 수 있다</em></p>\n<p><br></p>\n<h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><p>리눅스 컨테이너를 기반으로 하는 오픈소스 프로젝트</p>\n<p>namespace, control group(cgroup)과 같은 리눅스 커널 기능을 이용해서 OS 위에 컨테이너들을 생성하는 기술이다.</p>\n<p><br><br><br></p>\n<h3 id=\"3-Cloud-Native-Computing-Foundation-CNCF\"><a href=\"#3-Cloud-Native-Computing-Foundation-CNCF\" class=\"headerlink\" title=\"3. Cloud Native Computing Foundation (CNCF)\"></a>3. Cloud Native Computing Foundation (CNCF)</h3><p><strong>Cloud Native Computing</strong> 은 클라우드 컴퓨팅 모델의 장점을 모두 활용하는 애플리케이션을 개발하고 실행하기 위한 접근 방식이다.</p>\n<p>microservice로 앱을 배포하고, 컨테이너 별로 패키징하고, 리소스 사용량을 최적화하는 동적 조절을위해 오픈소스 소프트웨어를 사용한다. <strong>Cloud Native Computing Foundation (CNCF)</strong> 는 이러한 클라우드 기술과 관련된 표준형을 개발하려는 단체이며, <strong><u>Kubernetes</u></strong>가 유일한 중심 프로젝트로 편성되었다.</p>\n<blockquote>\n<p> kubernetes, prometheus, envoy, istio, …</p>\n</blockquote>\n<p><br></p>\n<p><br></p>\n<p><br></p>\n<h1 id=\"Kubernetes-k8s-란\"><a href=\"#Kubernetes-k8s-란\" class=\"headerlink\" title=\"Kubernetes (k8s) 란?\"></a>Kubernetes (k8s) 란?</h1><blockquote>\n<p><em>그래서 MSA형태로 개발된 서비스들을 Docker로 컨테이너화해서 띄우긴했는데..</em></p>\n<ul>\n<li>여러대의 물리서버에서 각각 관리하기도 어렵고</li>\n</ul>\n<ul>\n<li><p><u>lifecycle management</u>도 필요하고 (문제 대응, 패치, 업데이트 등)</p>\n</li>\n<li><p>컨테이너 배포, 스케일링, 오퍼레이팅등도 자동으로 되면 좋겠는데…</p>\n<p>=&gt; (“해결사가 왔어!”) <strong>Kubernetes</strong></p>\n</li>\n</ul>\n</blockquote>\n<p><br></p>\n<h3 id=\"Kubernetes\"><a href=\"#Kubernetes\" class=\"headerlink\" title=\"Kubernetes\"></a>Kubernetes</h3><p><strong>kubernetes</strong>는 “Docker container Orchestration tool” </p>\n<p>컨테이너화된 어플리케이션을 Automatic deployment / Scaling / Management</p>\n<p>- 그리스어로 ‘키잡이’라는 뜻으로, 줄여서 k8s라고 부른다. (k와 s사이에 8글자)</p>\n<p>- Google에서 최초 개발되었고 현재는 CNCF에 기증된 상태</p>\n<blockquote>\n<p><em>service를 host os를 공유하는 container화해서 올리는  <strong>docker</strong></em></p>\n<p><em>docker를 관리하는 <strong>k8s</strong>  (kubernetes)</em> </p>\n<p><em>이러한 k8s application들을 chart화 시키고 관리하는 <strong>helm</strong></em></p>\n</blockquote>\n<p><br></p>\n<h3 id=\"k8s-Object\"><a href=\"#k8s-Object\" class=\"headerlink\" title=\"k8s Object\"></a>k8s Object</h3><ul>\n<li><strong>Pod</strong> (name + spec + containers)</li>\n</ul>\n<p>- k8s의 가장 기본단위이자 Container의 묶음</p>\n<p>- pod 단위로 network namespace와 ip 가질 수 있음 (!= namespace in k8s)</p>\n<p>- 같은 pod에서는 같은 volume 접근가능</p>\n<p><br></p>\n<ul>\n<li><strong>ReplicaSet</strong> (<strong>Pod</strong> + replicas)</li>\n</ul>\n<p>- <u>replica</u>는 복제라는 의미로 replicas 수만큼 pod가 유지되도록 관리된다</p>\n<p>- pod는 죽으면 다시 되살리지않지만, ReplicaSet으로 만들면 replicas 수 (=pod 수)에 맞게 계속 살린다</p>\n<p>- (단, 모니터링이 되어 autoscaler가 작동되고 있는 상황이어야 함)</p>\n<p><br></p>\n<ul>\n<li><strong>Deployment</strong> (<strong>ReplicasSet</strong> + History (revision))</li>\n</ul>\n<p>- deployment는 name + replicas + pod 내용으로 구성되고, 대부분은 deployment를 사용해서 배포한다</p>\n<p>- 버전별로 설치/롤백되고 배포 관리가 가능하다</p>\n<p>- apps/v1일때는 <u>selector</u>가 있어야 <u>labels</u>를 가져올 수 있다</p>\n<blockquote>\n<p>​    <code>kubectl create deployment.yaml</code> <em>로 Deployment를 생성할 때 순서를 확인해보면 ,</em></p>\n<p>​    <em>“ Deployment -&gt; ReplicaSet -&gt; Pod “  순으로 생성된다</em></p>\n</blockquote>\n<p><br></p>\n<ul>\n<li><strong>Service</strong></li>\n</ul>\n<p>Load balancer를 이용하여 여러 pod들을 하나의 ip, port로 묶어서 제공하는 DNS이다</p>\n<p>그 기준은 <u>label selector</u> 로, 특정 label을 가진 것들을 하나의 서비스로 묶는다.</p>\n<blockquote>\n<p>Service object 노출 방식 3가지</p>\n<ol>\n<li><strong>ClusterIP</strong> - default값으로, Service에 Cluster IP (내부 IP)를 할당한다. 클러스터 내부에서만 접근 가능하고 외부에서는 접근이 불가능</li>\n<li><strong>NodePort</strong> - 각각의 Node의 IP와 static 포트를 노출하여 접근가능하게 하고, 클러스터 외부에서도 접근가능</li>\n<li><strong>Load Balancer</strong> - Cloud provider(GCE/AWS)와 같은 외부IP를 가진 Load balancer에게 Service를 노출</li>\n</ol>\n</blockquote>\n<p><br></p>\n<ul>\n<li>그 외 고오급 오브젝트</li>\n</ul>\n<p>- <strong>DaemonSet</strong> : 맵핑된 label이 있는 node가 추가되면 자동으로 해당 node에 pod 생성을 보장 (scaling)</p>\n<p>- <strong>StatefulSet</strong> : 컨테이너가 제거/재시작되어도 상태의 영속성과 지속성을 보장    =&gt; like DB<br><br></p>\n<blockquote>\n<p>- <strong>Affinity</strong> : kube-schedular에게 정보 제공. 부하 분산 또는 버전관리 가능</p>\n<p>( Session <strong>Affinity</strong> - sticky session 제공 (canary deployment) )</p>\n</blockquote>\n<p><br><br><br></p>\n<h3 id=\"기타-Keyword\"><a href=\"#기타-Keyword\" class=\"headerlink\" title=\"기타 Keyword\"></a>기타 Keyword</h3><p><strong>Docker 배포</strong></p>\n<blockquote>\n<p>특징 : 확장성, 표준성, 이미지 기반, 환경변수로 제어하는 설정, 공유자원..</p>\n</blockquote>\n<p>배포툴 : <u><strong>kubernetes</strong></u>, docker swarm, coreos, fleet,…</p>\n<p><br></p>\n<p><strong>Kubernetes 배포 프로세스</strong></p>\n<blockquote>\n<p><em>binary build -&gt; containerizing(image) -&gt; push image -&gt; service define -&gt; test deploy (canary test) -&gt; prod deploy</em>  </p>\n<p>=&gt; 어렵고 복잡. 이런 배포 프로세스를 통합/자동화하는 CICD (배포툴) 필요!</p>\n</blockquote>\n<p>배포툴 : <u>kubespray</u>, kubeadm, kops, … (CaaS 지원)</p>\n<p><br><br><br></p>\n<p>* <strong>오케스트레이션</strong> (Orchestration)</p>\n<p>여러 서버를 운영할때, 이들을 관리하는 것</p>\n<ul>\n<li><p>IaC를 돕는 설정관련 도구는 chef puppet <u>Ansible</u> SaltStack…</p>\n</li>\n<li><p>CI/CD 관리 도구는 Travis CI, <u>Jenkins</u>, Circle CI ..</p>\n</li>\n<li><p>컨테이너관리 도구는 Docker swarm, <u>Kubernetes</u> …</p>\n</li>\n</ul>\n<p><br></p>\n<p>* <strong>Ansible</strong></p>\n<p>구성관리 tool로, 인프라 관리과정을 코드로 기술한 IaC (Infra as Code)를 효율적이고 자동으로 관리할수있는 인프라 도구.</p>\n<p>Python 기반의 개발 + YAML로 정의 + JSON으로 통신</p>\n<p>초기설정이나 모니터링, 변경사항 추적이 불가능하다는 단점이 있지만, shell command를 제외하고는 모두 <strong>Idempotency(멱등성)</strong> 을 제공한다.</p>\n<blockquote>\n<p> <em>kubespray는 ansible 기반의 배포툴이다.</em></p>\n</blockquote>\n<p><br></p>\n<p>* <strong>Helm</strong></p>\n<p>Chart라는 개념으로 kubernetes의 application을 정의, 배포하고 관리</p>\n<ul>\n<li>Chart: app 구성하는 Kubernetes 객체들을 정의한 manifest template파일 및 설정묶음</li>\n<li>Cient (helm client, CLI) - Server (<strong>tiller</strong>, pod형태로 배포됨) 구조</li>\n<li>Release: client 통해 kube 위에 배포된 app</li>\n</ul>\n<p>=&gt; helm client 설치 후 tiller server를 kubernetes cluster위에 설치해야함</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm init (—upgrade)\t// tiller 설치 </span><br><span class=\"line\">helm install \t\t\t// repository에 등록된 chart를 client-&gt;tiller로 보냄</span><br><span class=\"line\">helm lint\t\t\t\t// chart의 문법검사</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<p>* <strong>CI/CD</strong></p>\n<ul>\n<li><p>CI (Continuous Integration): 지속적 통합, 자주 Build &amp; Packaging</p>\n</li>\n<li><p>CD (Continous Delivery / Deployment): 지속적 배포, 자주 Deployment</p>\n</li>\n</ul>\n<p><br><br><br></p>\n<h3 id=\"참조\"><a href=\"#참조\" class=\"headerlink\" title=\"참조\"></a>참조</h3><ol>\n<li><a href=\"https://www.samsungsds.com/global/ko/support/insights/101917_RD_Cloudnative.html\" target=\"_blank\" rel=\"noopener\">https://www.samsungsds.com/global/ko/support/insights/101917_RD_Cloudnative.html</a>)</li>\n<li><a href=\"https://engineering.linecorp.com/ko/blog/infrastructure-trends-open-infra-days-korea-2018/\" target=\"_blank\" rel=\"noopener\">https://engineering.linecorp.com/ko/blog/infrastructure-trends-open-infra-days-korea-2018/</a></li>\n<li>갓승규님 블로그 <a href=\"https://ahnseungkyu.com/\" target=\"_blank\" rel=\"noopener\">https://ahnseungkyu.com/</a> </li>\n<li>Google Cloud - JAM k8s 입문반 QWIK LAB 진행</li>\n</ol>\n"},{"title":"2019 NAVER CAMPUS HACKDAY SUMMER 후기","date":"2019-06-30T07:13:28.000Z","_content":"\n\n언젠가부터 주위 동기들이 *해커톤 (Hackaton)* 에서 좋은 경험을 하고 오는 걸 보면서,\n항상 나도 해보고 싶다는 마음은 있었지만 현생이 바쁘다는 이유로 단 한번도 도전해보지 않았었다.\n\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60393712-742a5400-9b54-11e9-9771-03862d5b94df.jpg\" width=30%>\n<i>핑계는...</i></center>\n\n길고 길었던 지옥의 사망년을 벗어난 기념으로, 지난 4월 <U>세 개의 해커톤</U>을 지원했고 운 좋게 **<U>두 개</U>를 합격하였다**.\n이번 포스트에서는 그 중 **NAVER CAMPUS HACKDAY** 후기를 작성하고자 한다.\n> 나머지 하나는 추후에 업로드 예정이다. ~~아마도...~~\n> \n\n<br/>\n\n---\n\n<br/>\n\n\n# 2019 NAVER CAMPUS HACKDAY SUMMER\n\n<center><img src=\"https://d2.naver.com/content/images/2019/03/19CHACK_S.png\" width=60%></center>\n\n> NAVER D2 - CAMPUS HACKDAY 행사 안내 https://d2.naver.com/news/5009947\n> \n> GITHUB Page https://github.com/NAVER-CAMPUS-HACKDAY/common\n> \n\n깃헙 레포의 이슈에 있는 37개의 주제 중 희망하는 1~2개의 주제를 골라 지원서를 작성하고, 4월 13일에 온라인 코딩 테스트를 보았다.\n\n코딩 테스트는 원하는 시간에 접속하여 제한시간 두 시간동안 3문제를 풀어야 했고, 문제 난이도는 그리 높은 편은 아니었던 것 같다. 제출하는 시간도 기록되었기 때문에 테스트 케이스를 적당히 확인하고 한 시간 조금 넘은 시점에 제출했다.\n\n후담이지만 [Google code jam](https://codingcompetitions.withgoogle.com/codejam)의 'Round 1A 2019' 도 같은 날에 진행되어서 스타벅스에 앉아서 하루죙일 정신없이 문제만 풀었다. 🤦🏻‍♀️\n\n<br/>\n\n### 🎉 햅격~ 🎉\n<img src=\"https://user-images.githubusercontent.com/26691216/60394163-02093d80-9b5b-11e9-8129-2444f06d0741.png\" width=\"905\">\n\n기대 안하고 있었지만 사실 기대하긴 했다. (ㅋㅋㅋㅋㅋㅋㅋㅋㅋ)\n\n해커톤 중에서도 Naver hackday는 꼭 한번쯤 가보고 싶었던 행사였기 때문에 특히 좋았다. 기쁜 와중에 딱 날짜가 종설 프로젝트 중간 발표 날이라서 팀원들에게 미리 양해를 구했는데, 다행히 마음씨 좋은 우리 팀원분들은 너그럽게 이해해주셨다.\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60394226-0124db80-9b5c-11e9-80ed-221836478984.png\" width=40%></center>\n\n<br/>\n\n---\n\n<br/>\n\n## Before Hack-day\n\n내가 수행하게 된 주제는 **\"컨테이너 기반 쇼핑 상품 정보 수신\"** 으로, 세 명이 한 팀을 이루고 멘토님 한 분이 함께 해주셨다. \n\n> **[컨테이너 기반 쇼핑 상품 정보 수신]**\n>\n> *https://github.com/NAVER-CAMPUS-HACKDAY/common/issues/7*\n> \n> 상품정보 수집을 위하여 각 쇼핑몰에서 제공하는 상품정보 **EP**(Engine Page)를 주기적으로 수집하여 변경된 정보를 체크하고 서비스에 반영하고 있다. 해당 작업의 **확장성 및 고가용성**을 위하여 Kubernetes 등의 컨테이너 환경에서 Task Agent 들이 운용될 수 있도록 설계 및 구현이 필요하다.\n> \n\n\n해커톤 행사 당일에 주제 선정과 개발이 모두 이루어지는 다른 해커톤들과는 다르게 Naver Campus Hackday는 본인이 지원한 주제에 따라 팀이 꾸려지고, 사전에 멘토님의 가이드에 따라 팀끼리 개발을 어느정도 진행하기도 한다. ( → 해당 부분은 팀by팀 인 듯)\n\n프로젝트에 대해서는 멘토님께 사전에 여쭤봤을 때, 구체적인 플로우는 공개할 수 없으나 내가 짠 코드는 무관하다고 답변을 주셔서 공식 Hackday github 이슈에 노출되어있는 프로젝트의 개괄적인 내용과 함께 느낀점만 간략하게 정리하고자 한다.\n\n<br/>\n\n우리 팀의 경우 특히 인프라 구축이 필요한 주제였기 때문에 사전에 LINE과 Github을 통해 온라인 회의를 지속적으로 진행했다. 이를 통해 나는 아래와 같은 사전 준비를 하고서 Hackday에 참가하였다.\n\n\n 1. MQ(Message Queue), 데이터 처리 방법 등에 대한 이해\n \t- MQ란 무엇이고, 프로젝트에 적합한 프로젝트는 무엇인가?\n \t- 데이터 처리 방식 중 Batch와 Stream의 차이와 각각의 장단점은?\n \t- 확장성과 고가용성을 고려하였을 때 적합한 데이터 저장 및 분석 방법은?\n\n 2. 서버 운용 및 클러스터링 계획\n \t- 사전에 할당받은 10개의 서버를 어떻게 운용할 것인가?\n \t- 어떤 기술 스택을 사용할 것인가?\n \t- 어떤식으로 Clustering할 것인가?\n \t- 어떠한 플로우로 데이터를 처리하고, 어떻게 분석할 것인가? (설계)\n \t\n \t```\nContainer Management : Kubernetes\nMessage Queue : Kafka\nDatabase & Analytics Engine : Hbase + Spark\n```\n \t\n 3. 컨테이너 기반 (Kubernetes)\n\t- 어느 범위까지 컨테이너화할 것인가?\n\t- Kubernetes Clustering은 어떻게 구성 할 것인가?\n\t- Docker registry는 어떤식으로 사용할 것인가?\n\n<br/>\n\n그 외에도 대용량 데이터 처리임을 고려하여 어떻게하면 속도와 공간 효율성을 확보할 수 있을 지에 대한 고민을 정말 많이 했다.\n\n내가 알고 있는거라곤 '쿠버네티스' 다섯 글자 뿐...\n이때까지 이정도의 대용량 데이터 처리를 해본적이 없었고 MQ 나 Hadoop 사용 경험도 없었기 때문에 처음 접하는 것들이 대부분이었다. 책도 찾아 읽고 나름대로의 공부도 많이 해서 어느정도 설계까지는 했지만 막상 실제 인프라 구축은 막막하기만 했는데, 우리 팀에 데이터 마술사님(!)이 계셔서 초반 구축을 ~~알잘딱깔센~~ 해주셔서 🐶🍯 이었다.\n\nHackday 준비를 하면서 공부도 많이 됐지만 능력있고 열정있는 팀원님을 보면서 특히 많이 배웠다. 최고의 팀원 최고 bbb\n\n<br/>\n\n## D-day, Hack-day\n\nHackday 당일, 춘천으로 출발 전에 미리 모여 멘토님과 간단하게 점심 식사를 했다.\n그린 팩토리 근처 식당에서 돈까스 먹었는데 굉장히 맷-집 이더라. JMTGR.\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60395184-bb234400-9b6a-11e9-8966-64be35892e6b.jpg\" width=40%>\n??: 좋아해요? </center>\n\n멘토님을 처음 뵙는 자리라 조금 긴장도 됐었는데 생각보다 편한 분위기로 얘기를 나누고 근처 카페에서 커피도 사주셔서 감사하게 먹고 그린팩토리로 향했다.\n\n하지만 모든게 평화롭고 순조로운 가운데, **한가지 문제**가 있었다.\n\n팀원 분 중에 한 분이 몸이 아프셔서 당일 날 못 오신 것이다. 위에서 말했다 싶이 한 팀당 3명이 팀이었고, 대부분 세 명인 가운데 갑자기 우리팀만 둘이 되었다.\n\n이 때 느낌왔다. <U>오늘 숙소 구경은 물건너 갔음을.</U>\n\n<br/>\n\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60395094-3c79d700-9b69-11e9-9a2f-faf606655425.JPG\" width=50%>\n<i>행사 진행 장소인 NAVER CONNECT ONE은 내부 사진 공개를 금하고 있기 때문에 시설 모습이 보이는 구체적인 사진들은 공개할 수 없다.</i></center>\n\n<br/>\n\n사실 나와 다른 팀원님은 커네트원이 두 번째 방문이라 구경은 제쳐두고 회의실에만 박혀있었어서 사진도 거의 안찍었다. 때 맞춰 나와 밥 먹고 당 떨어지면 간식 가져오는 거 외에는 회의실에 스스로를 감금했다.\n\n왜냐고? 순조롭긴 개뿔 내가 해간거 하나도 안됐다. ~~tlqk~~\n\n> 인프라 특 _ 이유없이 갑자기 안됨\n> \n> 루까 특 _ 이유없긴 사실상 **본인 잘못**임\n> \n\n<br/>\n\n도착하자 마자 마음이 급했던 우리 팀은 곧 바로 회의를 시작했다. 사전에 온라인 회의를 통해 설계를 논의하긴 했었지만 확정은 아니었고, 그 이후로 각자가 고민했던 부분과 그 결과로 설계한 구조를 서로 공유하고 멘토님께 피드백을 받았다.\n\n***결론만 얘기하자면, 나와 다른 팀원님의 디자인은 완전히 달랐다.***\n\n같은 문제를 접했고 사용할 인프라도 같이 정했음에도 불구하고, 생각하는 해결 방식이 다른 것이다. 이런 점이 사실 놀랍기도 하고 또 각 방법의 장단점이 분명해서 어떤 설계에 따라 구현할지 토의를 하면서 많은 고민이 되었다. 결국 일단은 내 설계대로 진행하기로 결론을 냈지만, 여기의 가장 큰 이슈는 <U>Hackday 기간 안에 구현이 가능할지</U> 였다. \n\n> ✽ 프로젝트 내용은 공개 가능한 범위가 모호하여 일단 보류하고, 추후에 기회가 되는대로 짰던 코드와 함께 겪었던 문제점, 해결 과정, 느낀점 등을 따로 정리하려 한다.\n> \n\n<br/>\n\n#### '혹시'하면 '역시'다.\n\n<center>![c4796fa2653be1d6726b90fe3189184d](https://user-images.githubusercontent.com/26691216/60401215-0ebc7e80-9bb9-11e9-90bf-d301476adcce.gif)</center>\n<center><i>서버들은 이유 없이 돌아가며 터지고, <br/>\nKubernetes는 갑자기 막혔고, <br/>\nHbase Cluster도 급 터져 팀원님이 해결하시는 와중에 <br/>\n우려 했던 나의 Spark (정확히는 Scalar) 멘붕까지 <strong>터!져! Ba!by!</strong><br/>\n</i></center> \n\n새로운 도메인 지식 습득과 설계에 급급했던 나머지 나는 초반 인프라 구축 참여가 적었고 거기에 대한 이해도가 다소 부족했다. 그 중 Kafka는 비교적 많이 공부를 해갔지만 DB 쪽에는 신경을 많이 쓰지 못했더니,\n\n**Java로 Consumer와 Producer를 구현하긴 했는데 막상 데이터를 어떻게 다뤄야 되는지를 모르겠는 거다.**\n\n다른 팀원님이 DB 문제를 해결하고 계시는 동안 혼자 Consumer 모듈에 Spark를 적용해보려니 눈앞이 캄캄했다. 밤새 Spark가 대체 뭐며 어떻게 적용해야 하는지를 찾아봐도 참고하라고 주신 Scalar 코드를 봐도 좀 처럼 각이 안나왔다.\n이 때 사실 팀원분이 데이터 처리 경험이 나보다 많다는 이유로 나는 너무 안일하게 준비한게 아닌가라는 반성을 많이 했다.\n\n예상했던 대로 <U>그 좋은 숙소는 주인 없는 밤을 보내게 되었다</U>. 🛏\n\n<br/>\n<br/>\n\n다음 날 점심 식사 후, 최종 결과물을 멘토님께 공유하고 피드백을 받았다.\n\n처음에는 팀 프로젝트였지만 진행하다보니 계획했던 결과를 내기에는 부족함이 있어 결국 팀원 각자 나름의 구현 결과물을 내게 되었다.\n(각자의 설계를 기반으로 하되, 각자가 처한 상황에 따라 스펙을 조금씩 바꾸었다)\n\n밤새 구현한 걸 몇 번이고 뒤집어 엎어 최종적으로 계획 했던 동작은 구현하긴 했지만 '대용량 데이터 처리'와 '컨테이너 환경'에 대한 아쉬움은 어쩔 수 없었다. 이렇게 아쉬움을 한 가득 안고 **Campus Hackday**는 마무리 되었지만, 또 배워가는 것도 한 가득이라 여러모로 의미가 큰 행사였다.\n\n<br/>\n\n## After ..\n\nHackday를 다녀와서 가장 먼저는 **잤다**. 즈질 체력 증말;;\n\n그러고나서 까먹기 전에 부족했던 점과 배운 점을 정리하면서\n멘토님께 피드백 받은 부분과 스스로 아쉬웠던 부분은 인프라가 아직 남아있을 때 공부하면서 보완해보고자 했다.\n\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60398767-339ffa00-9b97-11e9-9caa-05023dba1d11.png\" width=\"210\">\n~~사람이 안하던 짓을 하면...~~ </center>\n\n생각했던 것보다 서버 회수 시기가 앞당겨져서 아쉽기는 했지만, 아쉬운대로 로컬에 최대한 동일한 테스트 환경을 구축해서 Code Refactoring / Test 와 정리한 내용 바탕의 문서 작성을 마치고 팀 Github에 Issue와 PR을 올림으로써 Hackday 프로젝트를 마무리 지었다.\n\n---\n\n<br/>\n\n#### 느낀점\n\nNaver Campus Hackday와 다른 해커톤과의 차이점은 실무에 어느정도 직접적인 연관이 있는 문제들을 접하고 그 중 본인이 관심있는 주제를 정할 수 있다는 점이고, 1박 2일 행사 기간 외에도 문제에 대해 좀 더 깊게 고민하고 개발할 수 있는 시간이 있다는 것이다. \n\n그리고 또 다른 큰 차이점은 **'경쟁이나 시험이 아니다'** 라는 것이다.\n다른 팀과의 내용 공유가 따로 없어 어떤 걸 어떻게 해결하셨는지 정말 궁금하긴 했지만, 대신에 비교도 없고 경쟁도 없다. \n\n물론 우수참가자에게는 네이버 인턴 면접기회를 준다는 혜택이 분명 존재하지만, 멘토님도 여러 차례 강조하셨던 것 처럼 정해진 답을 찾는다기보다 <U>실제 실무에서의 문제를 접하고 해결하는 경험</U>을 할 수 있는 기회이다. 경쟁이 아닌 또래의 열정적이고 실력있는 분들을 만나 많이 배우고 자극을 받을 수 있는 점이나, 현업의 네이버 개발자님의 멘토링과 피드백을 받을 수 있는 점 모두 다른 곳에서 경험 할 수 없는 귀한 경험인 것 같다.\n\n끝나고 가장 아쉬웠던 점 중 하나는 사전에 좀 더 많은 시간을 투자해서 당일에는 좀 더 활발한 네트워킹과 구체적인 피드백 (+ 코드 리뷰) 을 받을 수 있었으면 더 좋지 않았을까 하는 것이다. \n\n> *'Hackathon'* 이라고 생각하고 *'Hackday'* 를 충분히 즐기지 못했던게 아쉽긴하지만, \n근래 조금은 지쳤던 나에게 ***좋은 자극*** 이 되었음에는 틀림 없다.  \n\n<br/>\n\n혹시나 Naver Campus Hackday 참가를 희망하거나 이미 합격하신 분이 이 글을 읽는다면 조금의 도움이 되시길 바라며 글을 마친다.\n\n<br/>\n\n아디다디도스! 👋🏻\n\n<br/>\n","source":"_posts/2019-NAVER-HACKDAY-SUMMER-후기.md","raw":"---\ntitle: 2019 NAVER CAMPUS HACKDAY SUMMER 후기\ndate: 2019-06-30 16:13:28\ncategories: retrospect\ntags:\n\t- naver\n\t- hackathon\n\t- container\n\t- kafka\n\t- CNCF\n---\n\n\n언젠가부터 주위 동기들이 *해커톤 (Hackaton)* 에서 좋은 경험을 하고 오는 걸 보면서,\n항상 나도 해보고 싶다는 마음은 있었지만 현생이 바쁘다는 이유로 단 한번도 도전해보지 않았었다.\n\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60393712-742a5400-9b54-11e9-9771-03862d5b94df.jpg\" width=30%>\n<i>핑계는...</i></center>\n\n길고 길었던 지옥의 사망년을 벗어난 기념으로, 지난 4월 <U>세 개의 해커톤</U>을 지원했고 운 좋게 **<U>두 개</U>를 합격하였다**.\n이번 포스트에서는 그 중 **NAVER CAMPUS HACKDAY** 후기를 작성하고자 한다.\n> 나머지 하나는 추후에 업로드 예정이다. ~~아마도...~~\n> \n\n<br/>\n\n---\n\n<br/>\n\n\n# 2019 NAVER CAMPUS HACKDAY SUMMER\n\n<center><img src=\"https://d2.naver.com/content/images/2019/03/19CHACK_S.png\" width=60%></center>\n\n> NAVER D2 - CAMPUS HACKDAY 행사 안내 https://d2.naver.com/news/5009947\n> \n> GITHUB Page https://github.com/NAVER-CAMPUS-HACKDAY/common\n> \n\n깃헙 레포의 이슈에 있는 37개의 주제 중 희망하는 1~2개의 주제를 골라 지원서를 작성하고, 4월 13일에 온라인 코딩 테스트를 보았다.\n\n코딩 테스트는 원하는 시간에 접속하여 제한시간 두 시간동안 3문제를 풀어야 했고, 문제 난이도는 그리 높은 편은 아니었던 것 같다. 제출하는 시간도 기록되었기 때문에 테스트 케이스를 적당히 확인하고 한 시간 조금 넘은 시점에 제출했다.\n\n후담이지만 [Google code jam](https://codingcompetitions.withgoogle.com/codejam)의 'Round 1A 2019' 도 같은 날에 진행되어서 스타벅스에 앉아서 하루죙일 정신없이 문제만 풀었다. 🤦🏻‍♀️\n\n<br/>\n\n### 🎉 햅격~ 🎉\n<img src=\"https://user-images.githubusercontent.com/26691216/60394163-02093d80-9b5b-11e9-8129-2444f06d0741.png\" width=\"905\">\n\n기대 안하고 있었지만 사실 기대하긴 했다. (ㅋㅋㅋㅋㅋㅋㅋㅋㅋ)\n\n해커톤 중에서도 Naver hackday는 꼭 한번쯤 가보고 싶었던 행사였기 때문에 특히 좋았다. 기쁜 와중에 딱 날짜가 종설 프로젝트 중간 발표 날이라서 팀원들에게 미리 양해를 구했는데, 다행히 마음씨 좋은 우리 팀원분들은 너그럽게 이해해주셨다.\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60394226-0124db80-9b5c-11e9-80ed-221836478984.png\" width=40%></center>\n\n<br/>\n\n---\n\n<br/>\n\n## Before Hack-day\n\n내가 수행하게 된 주제는 **\"컨테이너 기반 쇼핑 상품 정보 수신\"** 으로, 세 명이 한 팀을 이루고 멘토님 한 분이 함께 해주셨다. \n\n> **[컨테이너 기반 쇼핑 상품 정보 수신]**\n>\n> *https://github.com/NAVER-CAMPUS-HACKDAY/common/issues/7*\n> \n> 상품정보 수집을 위하여 각 쇼핑몰에서 제공하는 상품정보 **EP**(Engine Page)를 주기적으로 수집하여 변경된 정보를 체크하고 서비스에 반영하고 있다. 해당 작업의 **확장성 및 고가용성**을 위하여 Kubernetes 등의 컨테이너 환경에서 Task Agent 들이 운용될 수 있도록 설계 및 구현이 필요하다.\n> \n\n\n해커톤 행사 당일에 주제 선정과 개발이 모두 이루어지는 다른 해커톤들과는 다르게 Naver Campus Hackday는 본인이 지원한 주제에 따라 팀이 꾸려지고, 사전에 멘토님의 가이드에 따라 팀끼리 개발을 어느정도 진행하기도 한다. ( → 해당 부분은 팀by팀 인 듯)\n\n프로젝트에 대해서는 멘토님께 사전에 여쭤봤을 때, 구체적인 플로우는 공개할 수 없으나 내가 짠 코드는 무관하다고 답변을 주셔서 공식 Hackday github 이슈에 노출되어있는 프로젝트의 개괄적인 내용과 함께 느낀점만 간략하게 정리하고자 한다.\n\n<br/>\n\n우리 팀의 경우 특히 인프라 구축이 필요한 주제였기 때문에 사전에 LINE과 Github을 통해 온라인 회의를 지속적으로 진행했다. 이를 통해 나는 아래와 같은 사전 준비를 하고서 Hackday에 참가하였다.\n\n\n 1. MQ(Message Queue), 데이터 처리 방법 등에 대한 이해\n \t- MQ란 무엇이고, 프로젝트에 적합한 프로젝트는 무엇인가?\n \t- 데이터 처리 방식 중 Batch와 Stream의 차이와 각각의 장단점은?\n \t- 확장성과 고가용성을 고려하였을 때 적합한 데이터 저장 및 분석 방법은?\n\n 2. 서버 운용 및 클러스터링 계획\n \t- 사전에 할당받은 10개의 서버를 어떻게 운용할 것인가?\n \t- 어떤 기술 스택을 사용할 것인가?\n \t- 어떤식으로 Clustering할 것인가?\n \t- 어떠한 플로우로 데이터를 처리하고, 어떻게 분석할 것인가? (설계)\n \t\n \t```\nContainer Management : Kubernetes\nMessage Queue : Kafka\nDatabase & Analytics Engine : Hbase + Spark\n```\n \t\n 3. 컨테이너 기반 (Kubernetes)\n\t- 어느 범위까지 컨테이너화할 것인가?\n\t- Kubernetes Clustering은 어떻게 구성 할 것인가?\n\t- Docker registry는 어떤식으로 사용할 것인가?\n\n<br/>\n\n그 외에도 대용량 데이터 처리임을 고려하여 어떻게하면 속도와 공간 효율성을 확보할 수 있을 지에 대한 고민을 정말 많이 했다.\n\n내가 알고 있는거라곤 '쿠버네티스' 다섯 글자 뿐...\n이때까지 이정도의 대용량 데이터 처리를 해본적이 없었고 MQ 나 Hadoop 사용 경험도 없었기 때문에 처음 접하는 것들이 대부분이었다. 책도 찾아 읽고 나름대로의 공부도 많이 해서 어느정도 설계까지는 했지만 막상 실제 인프라 구축은 막막하기만 했는데, 우리 팀에 데이터 마술사님(!)이 계셔서 초반 구축을 ~~알잘딱깔센~~ 해주셔서 🐶🍯 이었다.\n\nHackday 준비를 하면서 공부도 많이 됐지만 능력있고 열정있는 팀원님을 보면서 특히 많이 배웠다. 최고의 팀원 최고 bbb\n\n<br/>\n\n## D-day, Hack-day\n\nHackday 당일, 춘천으로 출발 전에 미리 모여 멘토님과 간단하게 점심 식사를 했다.\n그린 팩토리 근처 식당에서 돈까스 먹었는데 굉장히 맷-집 이더라. JMTGR.\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60395184-bb234400-9b6a-11e9-8966-64be35892e6b.jpg\" width=40%>\n??: 좋아해요? </center>\n\n멘토님을 처음 뵙는 자리라 조금 긴장도 됐었는데 생각보다 편한 분위기로 얘기를 나누고 근처 카페에서 커피도 사주셔서 감사하게 먹고 그린팩토리로 향했다.\n\n하지만 모든게 평화롭고 순조로운 가운데, **한가지 문제**가 있었다.\n\n팀원 분 중에 한 분이 몸이 아프셔서 당일 날 못 오신 것이다. 위에서 말했다 싶이 한 팀당 3명이 팀이었고, 대부분 세 명인 가운데 갑자기 우리팀만 둘이 되었다.\n\n이 때 느낌왔다. <U>오늘 숙소 구경은 물건너 갔음을.</U>\n\n<br/>\n\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60395094-3c79d700-9b69-11e9-9a2f-faf606655425.JPG\" width=50%>\n<i>행사 진행 장소인 NAVER CONNECT ONE은 내부 사진 공개를 금하고 있기 때문에 시설 모습이 보이는 구체적인 사진들은 공개할 수 없다.</i></center>\n\n<br/>\n\n사실 나와 다른 팀원님은 커네트원이 두 번째 방문이라 구경은 제쳐두고 회의실에만 박혀있었어서 사진도 거의 안찍었다. 때 맞춰 나와 밥 먹고 당 떨어지면 간식 가져오는 거 외에는 회의실에 스스로를 감금했다.\n\n왜냐고? 순조롭긴 개뿔 내가 해간거 하나도 안됐다. ~~tlqk~~\n\n> 인프라 특 _ 이유없이 갑자기 안됨\n> \n> 루까 특 _ 이유없긴 사실상 **본인 잘못**임\n> \n\n<br/>\n\n도착하자 마자 마음이 급했던 우리 팀은 곧 바로 회의를 시작했다. 사전에 온라인 회의를 통해 설계를 논의하긴 했었지만 확정은 아니었고, 그 이후로 각자가 고민했던 부분과 그 결과로 설계한 구조를 서로 공유하고 멘토님께 피드백을 받았다.\n\n***결론만 얘기하자면, 나와 다른 팀원님의 디자인은 완전히 달랐다.***\n\n같은 문제를 접했고 사용할 인프라도 같이 정했음에도 불구하고, 생각하는 해결 방식이 다른 것이다. 이런 점이 사실 놀랍기도 하고 또 각 방법의 장단점이 분명해서 어떤 설계에 따라 구현할지 토의를 하면서 많은 고민이 되었다. 결국 일단은 내 설계대로 진행하기로 결론을 냈지만, 여기의 가장 큰 이슈는 <U>Hackday 기간 안에 구현이 가능할지</U> 였다. \n\n> ✽ 프로젝트 내용은 공개 가능한 범위가 모호하여 일단 보류하고, 추후에 기회가 되는대로 짰던 코드와 함께 겪었던 문제점, 해결 과정, 느낀점 등을 따로 정리하려 한다.\n> \n\n<br/>\n\n#### '혹시'하면 '역시'다.\n\n<center>![c4796fa2653be1d6726b90fe3189184d](https://user-images.githubusercontent.com/26691216/60401215-0ebc7e80-9bb9-11e9-90bf-d301476adcce.gif)</center>\n<center><i>서버들은 이유 없이 돌아가며 터지고, <br/>\nKubernetes는 갑자기 막혔고, <br/>\nHbase Cluster도 급 터져 팀원님이 해결하시는 와중에 <br/>\n우려 했던 나의 Spark (정확히는 Scalar) 멘붕까지 <strong>터!져! Ba!by!</strong><br/>\n</i></center> \n\n새로운 도메인 지식 습득과 설계에 급급했던 나머지 나는 초반 인프라 구축 참여가 적었고 거기에 대한 이해도가 다소 부족했다. 그 중 Kafka는 비교적 많이 공부를 해갔지만 DB 쪽에는 신경을 많이 쓰지 못했더니,\n\n**Java로 Consumer와 Producer를 구현하긴 했는데 막상 데이터를 어떻게 다뤄야 되는지를 모르겠는 거다.**\n\n다른 팀원님이 DB 문제를 해결하고 계시는 동안 혼자 Consumer 모듈에 Spark를 적용해보려니 눈앞이 캄캄했다. 밤새 Spark가 대체 뭐며 어떻게 적용해야 하는지를 찾아봐도 참고하라고 주신 Scalar 코드를 봐도 좀 처럼 각이 안나왔다.\n이 때 사실 팀원분이 데이터 처리 경험이 나보다 많다는 이유로 나는 너무 안일하게 준비한게 아닌가라는 반성을 많이 했다.\n\n예상했던 대로 <U>그 좋은 숙소는 주인 없는 밤을 보내게 되었다</U>. 🛏\n\n<br/>\n<br/>\n\n다음 날 점심 식사 후, 최종 결과물을 멘토님께 공유하고 피드백을 받았다.\n\n처음에는 팀 프로젝트였지만 진행하다보니 계획했던 결과를 내기에는 부족함이 있어 결국 팀원 각자 나름의 구현 결과물을 내게 되었다.\n(각자의 설계를 기반으로 하되, 각자가 처한 상황에 따라 스펙을 조금씩 바꾸었다)\n\n밤새 구현한 걸 몇 번이고 뒤집어 엎어 최종적으로 계획 했던 동작은 구현하긴 했지만 '대용량 데이터 처리'와 '컨테이너 환경'에 대한 아쉬움은 어쩔 수 없었다. 이렇게 아쉬움을 한 가득 안고 **Campus Hackday**는 마무리 되었지만, 또 배워가는 것도 한 가득이라 여러모로 의미가 큰 행사였다.\n\n<br/>\n\n## After ..\n\nHackday를 다녀와서 가장 먼저는 **잤다**. 즈질 체력 증말;;\n\n그러고나서 까먹기 전에 부족했던 점과 배운 점을 정리하면서\n멘토님께 피드백 받은 부분과 스스로 아쉬웠던 부분은 인프라가 아직 남아있을 때 공부하면서 보완해보고자 했다.\n\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60398767-339ffa00-9b97-11e9-9caa-05023dba1d11.png\" width=\"210\">\n~~사람이 안하던 짓을 하면...~~ </center>\n\n생각했던 것보다 서버 회수 시기가 앞당겨져서 아쉽기는 했지만, 아쉬운대로 로컬에 최대한 동일한 테스트 환경을 구축해서 Code Refactoring / Test 와 정리한 내용 바탕의 문서 작성을 마치고 팀 Github에 Issue와 PR을 올림으로써 Hackday 프로젝트를 마무리 지었다.\n\n---\n\n<br/>\n\n#### 느낀점\n\nNaver Campus Hackday와 다른 해커톤과의 차이점은 실무에 어느정도 직접적인 연관이 있는 문제들을 접하고 그 중 본인이 관심있는 주제를 정할 수 있다는 점이고, 1박 2일 행사 기간 외에도 문제에 대해 좀 더 깊게 고민하고 개발할 수 있는 시간이 있다는 것이다. \n\n그리고 또 다른 큰 차이점은 **'경쟁이나 시험이 아니다'** 라는 것이다.\n다른 팀과의 내용 공유가 따로 없어 어떤 걸 어떻게 해결하셨는지 정말 궁금하긴 했지만, 대신에 비교도 없고 경쟁도 없다. \n\n물론 우수참가자에게는 네이버 인턴 면접기회를 준다는 혜택이 분명 존재하지만, 멘토님도 여러 차례 강조하셨던 것 처럼 정해진 답을 찾는다기보다 <U>실제 실무에서의 문제를 접하고 해결하는 경험</U>을 할 수 있는 기회이다. 경쟁이 아닌 또래의 열정적이고 실력있는 분들을 만나 많이 배우고 자극을 받을 수 있는 점이나, 현업의 네이버 개발자님의 멘토링과 피드백을 받을 수 있는 점 모두 다른 곳에서 경험 할 수 없는 귀한 경험인 것 같다.\n\n끝나고 가장 아쉬웠던 점 중 하나는 사전에 좀 더 많은 시간을 투자해서 당일에는 좀 더 활발한 네트워킹과 구체적인 피드백 (+ 코드 리뷰) 을 받을 수 있었으면 더 좋지 않았을까 하는 것이다. \n\n> *'Hackathon'* 이라고 생각하고 *'Hackday'* 를 충분히 즐기지 못했던게 아쉽긴하지만, \n근래 조금은 지쳤던 나에게 ***좋은 자극*** 이 되었음에는 틀림 없다.  \n\n<br/>\n\n혹시나 Naver Campus Hackday 참가를 희망하거나 이미 합격하신 분이 이 글을 읽는다면 조금의 도움이 되시길 바라며 글을 마친다.\n\n<br/>\n\n아디다디도스! 👋🏻\n\n<br/>\n","slug":"2019-NAVER-HACKDAY-SUMMER-후기","published":1,"updated":"2019-06-30T20:20:59.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxlyibcw000d1n4y049nt5eb","content":"<p>언젠가부터 주위 동기들이 <em>해커톤 (Hackaton)</em> 에서 좋은 경험을 하고 오는 걸 보면서,<br>항상 나도 해보고 싶다는 마음은 있었지만 현생이 바쁘다는 이유로 단 한번도 도전해보지 않았었다.</p>\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60393712-742a5400-9b54-11e9-9771-03862d5b94df.jpg\" width=\"30%\"><br><i>핑계는…</i></center>\n\n<p>길고 길었던 지옥의 사망년을 벗어난 기념으로, 지난 4월 <u>세 개의 해커톤</u>을 지원했고 운 좋게 <strong><u>두 개</u>를 합격하였다</strong>.<br>이번 포스트에서는 그 중 <strong>NAVER CAMPUS HACKDAY</strong> 후기를 작성하고자 한다.</p>\n<blockquote>\n<p>나머지 하나는 추후에 업로드 예정이다. <del>아마도…</del></p>\n</blockquote>\n<p><br></p>\n<hr>\n<p><br></p>\n<h1 id=\"2019-NAVER-CAMPUS-HACKDAY-SUMMER\"><a href=\"#2019-NAVER-CAMPUS-HACKDAY-SUMMER\" class=\"headerlink\" title=\"2019 NAVER CAMPUS HACKDAY SUMMER\"></a>2019 NAVER CAMPUS HACKDAY SUMMER</h1><center><img src=\"https://d2.naver.com/content/images/2019/03/19CHACK_S.png\" width=\"60%\"></center>\n\n<blockquote>\n<p>NAVER D2 - CAMPUS HACKDAY 행사 안내 <a href=\"https://d2.naver.com/news/5009947\" target=\"_blank\" rel=\"noopener\">https://d2.naver.com/news/5009947</a></p>\n<p>GITHUB Page <a href=\"https://github.com/NAVER-CAMPUS-HACKDAY/common\" target=\"_blank\" rel=\"noopener\">https://github.com/NAVER-CAMPUS-HACKDAY/common</a></p>\n</blockquote>\n<p>깃헙 레포의 이슈에 있는 37개의 주제 중 희망하는 1~2개의 주제를 골라 지원서를 작성하고, 4월 13일에 온라인 코딩 테스트를 보았다.</p>\n<p>코딩 테스트는 원하는 시간에 접속하여 제한시간 두 시간동안 3문제를 풀어야 했고, 문제 난이도는 그리 높은 편은 아니었던 것 같다. 제출하는 시간도 기록되었기 때문에 테스트 케이스를 적당히 확인하고 한 시간 조금 넘은 시점에 제출했다.</p>\n<p>후담이지만 <a href=\"https://codingcompetitions.withgoogle.com/codejam\" target=\"_blank\" rel=\"noopener\">Google code jam</a>의 ‘Round 1A 2019’ 도 같은 날에 진행되어서 스타벅스에 앉아서 하루죙일 정신없이 문제만 풀었다. 🤦🏻‍♀️</p>\n<p><br></p>\n<h3 id=\"🎉-햅격-🎉\"><a href=\"#🎉-햅격-🎉\" class=\"headerlink\" title=\"🎉 햅격~ 🎉\"></a>🎉 햅격~ 🎉</h3><p><img src=\"https://user-images.githubusercontent.com/26691216/60394163-02093d80-9b5b-11e9-8129-2444f06d0741.png\" width=\"905\"></p>\n<p>기대 안하고 있었지만 사실 기대하긴 했다. (ㅋㅋㅋㅋㅋㅋㅋㅋㅋ)</p>\n<p>해커톤 중에서도 Naver hackday는 꼭 한번쯤 가보고 싶었던 행사였기 때문에 특히 좋았다. 기쁜 와중에 딱 날짜가 종설 프로젝트 중간 발표 날이라서 팀원들에게 미리 양해를 구했는데, 다행히 마음씨 좋은 우리 팀원분들은 너그럽게 이해해주셨다.</p>\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60394226-0124db80-9b5c-11e9-80ed-221836478984.png\" width=\"40%\"></center>\n\n<p><br></p>\n<hr>\n<p><br></p>\n<h2 id=\"Before-Hack-day\"><a href=\"#Before-Hack-day\" class=\"headerlink\" title=\"Before Hack-day\"></a>Before Hack-day</h2><p>내가 수행하게 된 주제는 <strong>“컨테이너 기반 쇼핑 상품 정보 수신”</strong> 으로, 세 명이 한 팀을 이루고 멘토님 한 분이 함께 해주셨다. </p>\n<blockquote>\n<p><strong>[컨테이너 기반 쇼핑 상품 정보 수신]</strong></p>\n<p><em><a href=\"https://github.com/NAVER-CAMPUS-HACKDAY/common/issues/7\" target=\"_blank\" rel=\"noopener\">https://github.com/NAVER-CAMPUS-HACKDAY/common/issues/7</a></em></p>\n<p>상품정보 수집을 위하여 각 쇼핑몰에서 제공하는 상품정보 <strong>EP</strong>(Engine Page)를 주기적으로 수집하여 변경된 정보를 체크하고 서비스에 반영하고 있다. 해당 작업의 <strong>확장성 및 고가용성</strong>을 위하여 Kubernetes 등의 컨테이너 환경에서 Task Agent 들이 운용될 수 있도록 설계 및 구현이 필요하다.</p>\n</blockquote>\n<p>해커톤 행사 당일에 주제 선정과 개발이 모두 이루어지는 다른 해커톤들과는 다르게 Naver Campus Hackday는 본인이 지원한 주제에 따라 팀이 꾸려지고, 사전에 멘토님의 가이드에 따라 팀끼리 개발을 어느정도 진행하기도 한다. ( → 해당 부분은 팀by팀 인 듯)</p>\n<p>프로젝트에 대해서는 멘토님께 사전에 여쭤봤을 때, 구체적인 플로우는 공개할 수 없으나 내가 짠 코드는 무관하다고 답변을 주셔서 공식 Hackday github 이슈에 노출되어있는 프로젝트의 개괄적인 내용과 함께 느낀점만 간략하게 정리하고자 한다.</p>\n<p><br></p>\n<p>우리 팀의 경우 특히 인프라 구축이 필요한 주제였기 때문에 사전에 LINE과 Github을 통해 온라인 회의를 지속적으로 진행했다. 이를 통해 나는 아래와 같은 사전 준비를 하고서 Hackday에 참가하였다.</p>\n<ol>\n<li><p>MQ(Message Queue), 데이터 처리 방법 등에 대한 이해</p>\n<ul>\n<li>MQ란 무엇이고, 프로젝트에 적합한 프로젝트는 무엇인가?</li>\n<li>데이터 처리 방식 중 Batch와 Stream의 차이와 각각의 장단점은?</li>\n<li>확장성과 고가용성을 고려하였을 때 적합한 데이터 저장 및 분석 방법은?</li>\n</ul>\n</li>\n<li><p>서버 운용 및 클러스터링 계획</p>\n<ul>\n<li>사전에 할당받은 10개의 서버를 어떻게 운용할 것인가?</li>\n<li>어떤 기술 스택을 사용할 것인가?</li>\n<li>어떤식으로 Clustering할 것인가?</li>\n<li><p>어떠한 플로우로 데이터를 처리하고, 어떻게 분석할 것인가? (설계)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Container Management : Kubernetes</span><br><span class=\"line\">Message Queue : Kafka</span><br><span class=\"line\">Database &amp; Analytics Engine : Hbase + Spark</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li>컨테이너 기반 (Kubernetes)<ul>\n<li>어느 범위까지 컨테이너화할 것인가?</li>\n<li>Kubernetes Clustering은 어떻게 구성 할 것인가?</li>\n<li>Docker registry는 어떤식으로 사용할 것인가?</li>\n</ul>\n</li>\n</ol>\n<p><br></p>\n<p>그 외에도 대용량 데이터 처리임을 고려하여 어떻게하면 속도와 공간 효율성을 확보할 수 있을 지에 대한 고민을 정말 많이 했다.</p>\n<p>내가 알고 있는거라곤 ‘쿠버네티스’ 다섯 글자 뿐…<br>이때까지 이정도의 대용량 데이터 처리를 해본적이 없었고 MQ 나 Hadoop 사용 경험도 없었기 때문에 처음 접하는 것들이 대부분이었다. 책도 찾아 읽고 나름대로의 공부도 많이 해서 어느정도 설계까지는 했지만 막상 실제 인프라 구축은 막막하기만 했는데, 우리 팀에 데이터 마술사님(!)이 계셔서 초반 구축을 <del>알잘딱깔센</del> 해주셔서 🐶🍯 이었다.</p>\n<p>Hackday 준비를 하면서 공부도 많이 됐지만 능력있고 열정있는 팀원님을 보면서 특히 많이 배웠다. 최고의 팀원 최고 bbb</p>\n<p><br></p>\n<h2 id=\"D-day-Hack-day\"><a href=\"#D-day-Hack-day\" class=\"headerlink\" title=\"D-day, Hack-day\"></a>D-day, Hack-day</h2><p>Hackday 당일, 춘천으로 출발 전에 미리 모여 멘토님과 간단하게 점심 식사를 했다.<br>그린 팩토리 근처 식당에서 돈까스 먹었는데 굉장히 맷-집 이더라. JMTGR.</p>\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60395184-bb234400-9b6a-11e9-8966-64be35892e6b.jpg\" width=\"40%\"><br>??: 좋아해요? </center>\n\n<p>멘토님을 처음 뵙는 자리라 조금 긴장도 됐었는데 생각보다 편한 분위기로 얘기를 나누고 근처 카페에서 커피도 사주셔서 감사하게 먹고 그린팩토리로 향했다.</p>\n<p>하지만 모든게 평화롭고 순조로운 가운데, <strong>한가지 문제</strong>가 있었다.</p>\n<p>팀원 분 중에 한 분이 몸이 아프셔서 당일 날 못 오신 것이다. 위에서 말했다 싶이 한 팀당 3명이 팀이었고, 대부분 세 명인 가운데 갑자기 우리팀만 둘이 되었다.</p>\n<p>이 때 느낌왔다. <u>오늘 숙소 구경은 물건너 갔음을.</u></p>\n<p><br></p>\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60395094-3c79d700-9b69-11e9-9a2f-faf606655425.JPG\" width=\"50%\"><br><i>행사 진행 장소인 NAVER CONNECT ONE은 내부 사진 공개를 금하고 있기 때문에 시설 모습이 보이는 구체적인 사진들은 공개할 수 없다.</i></center>\n\n<p><br></p>\n<p>사실 나와 다른 팀원님은 커네트원이 두 번째 방문이라 구경은 제쳐두고 회의실에만 박혀있었어서 사진도 거의 안찍었다. 때 맞춰 나와 밥 먹고 당 떨어지면 간식 가져오는 거 외에는 회의실에 스스로를 감금했다.</p>\n<p>왜냐고? 순조롭긴 개뿔 내가 해간거 하나도 안됐다. <del>tlqk</del></p>\n<blockquote>\n<p>인프라 특 _ 이유없이 갑자기 안됨</p>\n<p>루까 특 _ 이유없긴 사실상 <strong>본인 잘못</strong>임</p>\n</blockquote>\n<p><br></p>\n<p>도착하자 마자 마음이 급했던 우리 팀은 곧 바로 회의를 시작했다. 사전에 온라인 회의를 통해 설계를 논의하긴 했었지만 확정은 아니었고, 그 이후로 각자가 고민했던 부분과 그 결과로 설계한 구조를 서로 공유하고 멘토님께 피드백을 받았다.</p>\n<p><strong><em>결론만 얘기하자면, 나와 다른 팀원님의 디자인은 완전히 달랐다.</em></strong></p>\n<p>같은 문제를 접했고 사용할 인프라도 같이 정했음에도 불구하고, 생각하는 해결 방식이 다른 것이다. 이런 점이 사실 놀랍기도 하고 또 각 방법의 장단점이 분명해서 어떤 설계에 따라 구현할지 토의를 하면서 많은 고민이 되었다. 결국 일단은 내 설계대로 진행하기로 결론을 냈지만, 여기의 가장 큰 이슈는 <u>Hackday 기간 안에 구현이 가능할지</u> 였다. </p>\n<blockquote>\n<p>✽ 프로젝트 내용은 공개 가능한 범위가 모호하여 일단 보류하고, 추후에 기회가 되는대로 짰던 코드와 함께 겪었던 문제점, 해결 과정, 느낀점 등을 따로 정리하려 한다.</p>\n</blockquote>\n<p><br></p>\n<h4 id=\"‘혹시’하면-‘역시’다\"><a href=\"#‘혹시’하면-‘역시’다\" class=\"headerlink\" title=\"‘혹시’하면 ‘역시’다.\"></a>‘혹시’하면 ‘역시’다.</h4><center><img src=\"https://user-images.githubusercontent.com/26691216/60401215-0ebc7e80-9bb9-11e9-90bf-d301476adcce.gif\" alt=\"c4796fa2653be1d6726b90fe3189184d\"></center><br><center><i>서버들은 이유 없이 돌아가며 터지고, <br><br>Kubernetes는 갑자기 막혔고, <br><br>Hbase Cluster도 급 터져 팀원님이 해결하시는 와중에 <br><br>우려 했던 나의 Spark (정확히는 Scalar) 멘붕까지 <strong>터!져! Ba!by!</strong><br><br></i></center> \n\n<p>새로운 도메인 지식 습득과 설계에 급급했던 나머지 나는 초반 인프라 구축 참여가 적었고 거기에 대한 이해도가 다소 부족했다. 그 중 Kafka는 비교적 많이 공부를 해갔지만 DB 쪽에는 신경을 많이 쓰지 못했더니,</p>\n<p><strong>Java로 Consumer와 Producer를 구현하긴 했는데 막상 데이터를 어떻게 다뤄야 되는지를 모르겠는 거다.</strong></p>\n<p>다른 팀원님이 DB 문제를 해결하고 계시는 동안 혼자 Consumer 모듈에 Spark를 적용해보려니 눈앞이 캄캄했다. 밤새 Spark가 대체 뭐며 어떻게 적용해야 하는지를 찾아봐도 참고하라고 주신 Scalar 코드를 봐도 좀 처럼 각이 안나왔다.<br>이 때 사실 팀원분이 데이터 처리 경험이 나보다 많다는 이유로 나는 너무 안일하게 준비한게 아닌가라는 반성을 많이 했다.</p>\n<p>예상했던 대로 <u>그 좋은 숙소는 주인 없는 밤을 보내게 되었다</u>. 🛏</p>\n<p><br><br><br></p>\n<p>다음 날 점심 식사 후, 최종 결과물을 멘토님께 공유하고 피드백을 받았다.</p>\n<p>처음에는 팀 프로젝트였지만 진행하다보니 계획했던 결과를 내기에는 부족함이 있어 결국 팀원 각자 나름의 구현 결과물을 내게 되었다.<br>(각자의 설계를 기반으로 하되, 각자가 처한 상황에 따라 스펙을 조금씩 바꾸었다)</p>\n<p>밤새 구현한 걸 몇 번이고 뒤집어 엎어 최종적으로 계획 했던 동작은 구현하긴 했지만 ‘대용량 데이터 처리’와 ‘컨테이너 환경’에 대한 아쉬움은 어쩔 수 없었다. 이렇게 아쉬움을 한 가득 안고 <strong>Campus Hackday</strong>는 마무리 되었지만, 또 배워가는 것도 한 가득이라 여러모로 의미가 큰 행사였다.</p>\n<p><br></p>\n<h2 id=\"After\"><a href=\"#After\" class=\"headerlink\" title=\"After ..\"></a>After ..</h2><p>Hackday를 다녀와서 가장 먼저는 <strong>잤다</strong>. 즈질 체력 증말;;</p>\n<p>그러고나서 까먹기 전에 부족했던 점과 배운 점을 정리하면서<br>멘토님께 피드백 받은 부분과 스스로 아쉬웠던 부분은 인프라가 아직 남아있을 때 공부하면서 보완해보고자 했다.</p>\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60398767-339ffa00-9b97-11e9-9caa-05023dba1d11.png\" width=\"210\"><br><del>사람이 안하던 짓을 하면…</del> </center>\n\n<p>생각했던 것보다 서버 회수 시기가 앞당겨져서 아쉽기는 했지만, 아쉬운대로 로컬에 최대한 동일한 테스트 환경을 구축해서 Code Refactoring / Test 와 정리한 내용 바탕의 문서 작성을 마치고 팀 Github에 Issue와 PR을 올림으로써 Hackday 프로젝트를 마무리 지었다.</p>\n<hr>\n<p><br></p>\n<h4 id=\"느낀점\"><a href=\"#느낀점\" class=\"headerlink\" title=\"느낀점\"></a>느낀점</h4><p>Naver Campus Hackday와 다른 해커톤과의 차이점은 실무에 어느정도 직접적인 연관이 있는 문제들을 접하고 그 중 본인이 관심있는 주제를 정할 수 있다는 점이고, 1박 2일 행사 기간 외에도 문제에 대해 좀 더 깊게 고민하고 개발할 수 있는 시간이 있다는 것이다. </p>\n<p>그리고 또 다른 큰 차이점은 <strong>‘경쟁이나 시험이 아니다’</strong> 라는 것이다.<br>다른 팀과의 내용 공유가 따로 없어 어떤 걸 어떻게 해결하셨는지 정말 궁금하긴 했지만, 대신에 비교도 없고 경쟁도 없다. </p>\n<p>물론 우수참가자에게는 네이버 인턴 면접기회를 준다는 혜택이 분명 존재하지만, 멘토님도 여러 차례 강조하셨던 것 처럼 정해진 답을 찾는다기보다 <u>실제 실무에서의 문제를 접하고 해결하는 경험</u>을 할 수 있는 기회이다. 경쟁이 아닌 또래의 열정적이고 실력있는 분들을 만나 많이 배우고 자극을 받을 수 있는 점이나, 현업의 네이버 개발자님의 멘토링과 피드백을 받을 수 있는 점 모두 다른 곳에서 경험 할 수 없는 귀한 경험인 것 같다.</p>\n<p>끝나고 가장 아쉬웠던 점 중 하나는 사전에 좀 더 많은 시간을 투자해서 당일에는 좀 더 활발한 네트워킹과 구체적인 피드백 (+ 코드 리뷰) 을 받을 수 있었으면 더 좋지 않았을까 하는 것이다. </p>\n<blockquote>\n<p><em>‘Hackathon’</em> 이라고 생각하고 <em>‘Hackday’</em> 를 충분히 즐기지 못했던게 아쉽긴하지만,<br>근래 조금은 지쳤던 나에게 <strong><em>좋은 자극</em></strong> 이 되었음에는 틀림 없다.  </p>\n</blockquote>\n<p><br></p>\n<p>혹시나 Naver Campus Hackday 참가를 희망하거나 이미 합격하신 분이 이 글을 읽는다면 조금의 도움이 되시길 바라며 글을 마친다.</p>\n<p><br></p>\n<p>아디다디도스! 👋🏻</p>\n<p><br></p>\n","site":{"data":{}},"excerpt":"","more":"<p>언젠가부터 주위 동기들이 <em>해커톤 (Hackaton)</em> 에서 좋은 경험을 하고 오는 걸 보면서,<br>항상 나도 해보고 싶다는 마음은 있었지만 현생이 바쁘다는 이유로 단 한번도 도전해보지 않았었다.</p>\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60393712-742a5400-9b54-11e9-9771-03862d5b94df.jpg\" width=\"30%\"><br><i>핑계는…</i></center>\n\n<p>길고 길었던 지옥의 사망년을 벗어난 기념으로, 지난 4월 <u>세 개의 해커톤</u>을 지원했고 운 좋게 <strong><u>두 개</u>를 합격하였다</strong>.<br>이번 포스트에서는 그 중 <strong>NAVER CAMPUS HACKDAY</strong> 후기를 작성하고자 한다.</p>\n<blockquote>\n<p>나머지 하나는 추후에 업로드 예정이다. <del>아마도…</del></p>\n</blockquote>\n<p><br></p>\n<hr>\n<p><br></p>\n<h1 id=\"2019-NAVER-CAMPUS-HACKDAY-SUMMER\"><a href=\"#2019-NAVER-CAMPUS-HACKDAY-SUMMER\" class=\"headerlink\" title=\"2019 NAVER CAMPUS HACKDAY SUMMER\"></a>2019 NAVER CAMPUS HACKDAY SUMMER</h1><center><img src=\"https://d2.naver.com/content/images/2019/03/19CHACK_S.png\" width=\"60%\"></center>\n\n<blockquote>\n<p>NAVER D2 - CAMPUS HACKDAY 행사 안내 <a href=\"https://d2.naver.com/news/5009947\" target=\"_blank\" rel=\"noopener\">https://d2.naver.com/news/5009947</a></p>\n<p>GITHUB Page <a href=\"https://github.com/NAVER-CAMPUS-HACKDAY/common\" target=\"_blank\" rel=\"noopener\">https://github.com/NAVER-CAMPUS-HACKDAY/common</a></p>\n</blockquote>\n<p>깃헙 레포의 이슈에 있는 37개의 주제 중 희망하는 1~2개의 주제를 골라 지원서를 작성하고, 4월 13일에 온라인 코딩 테스트를 보았다.</p>\n<p>코딩 테스트는 원하는 시간에 접속하여 제한시간 두 시간동안 3문제를 풀어야 했고, 문제 난이도는 그리 높은 편은 아니었던 것 같다. 제출하는 시간도 기록되었기 때문에 테스트 케이스를 적당히 확인하고 한 시간 조금 넘은 시점에 제출했다.</p>\n<p>후담이지만 <a href=\"https://codingcompetitions.withgoogle.com/codejam\" target=\"_blank\" rel=\"noopener\">Google code jam</a>의 ‘Round 1A 2019’ 도 같은 날에 진행되어서 스타벅스에 앉아서 하루죙일 정신없이 문제만 풀었다. 🤦🏻‍♀️</p>\n<p><br></p>\n<h3 id=\"🎉-햅격-🎉\"><a href=\"#🎉-햅격-🎉\" class=\"headerlink\" title=\"🎉 햅격~ 🎉\"></a>🎉 햅격~ 🎉</h3><p><img src=\"https://user-images.githubusercontent.com/26691216/60394163-02093d80-9b5b-11e9-8129-2444f06d0741.png\" width=\"905\"></p>\n<p>기대 안하고 있었지만 사실 기대하긴 했다. (ㅋㅋㅋㅋㅋㅋㅋㅋㅋ)</p>\n<p>해커톤 중에서도 Naver hackday는 꼭 한번쯤 가보고 싶었던 행사였기 때문에 특히 좋았다. 기쁜 와중에 딱 날짜가 종설 프로젝트 중간 발표 날이라서 팀원들에게 미리 양해를 구했는데, 다행히 마음씨 좋은 우리 팀원분들은 너그럽게 이해해주셨다.</p>\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60394226-0124db80-9b5c-11e9-80ed-221836478984.png\" width=\"40%\"></center>\n\n<p><br></p>\n<hr>\n<p><br></p>\n<h2 id=\"Before-Hack-day\"><a href=\"#Before-Hack-day\" class=\"headerlink\" title=\"Before Hack-day\"></a>Before Hack-day</h2><p>내가 수행하게 된 주제는 <strong>“컨테이너 기반 쇼핑 상품 정보 수신”</strong> 으로, 세 명이 한 팀을 이루고 멘토님 한 분이 함께 해주셨다. </p>\n<blockquote>\n<p><strong>[컨테이너 기반 쇼핑 상품 정보 수신]</strong></p>\n<p><em><a href=\"https://github.com/NAVER-CAMPUS-HACKDAY/common/issues/7\" target=\"_blank\" rel=\"noopener\">https://github.com/NAVER-CAMPUS-HACKDAY/common/issues/7</a></em></p>\n<p>상품정보 수집을 위하여 각 쇼핑몰에서 제공하는 상품정보 <strong>EP</strong>(Engine Page)를 주기적으로 수집하여 변경된 정보를 체크하고 서비스에 반영하고 있다. 해당 작업의 <strong>확장성 및 고가용성</strong>을 위하여 Kubernetes 등의 컨테이너 환경에서 Task Agent 들이 운용될 수 있도록 설계 및 구현이 필요하다.</p>\n</blockquote>\n<p>해커톤 행사 당일에 주제 선정과 개발이 모두 이루어지는 다른 해커톤들과는 다르게 Naver Campus Hackday는 본인이 지원한 주제에 따라 팀이 꾸려지고, 사전에 멘토님의 가이드에 따라 팀끼리 개발을 어느정도 진행하기도 한다. ( → 해당 부분은 팀by팀 인 듯)</p>\n<p>프로젝트에 대해서는 멘토님께 사전에 여쭤봤을 때, 구체적인 플로우는 공개할 수 없으나 내가 짠 코드는 무관하다고 답변을 주셔서 공식 Hackday github 이슈에 노출되어있는 프로젝트의 개괄적인 내용과 함께 느낀점만 간략하게 정리하고자 한다.</p>\n<p><br></p>\n<p>우리 팀의 경우 특히 인프라 구축이 필요한 주제였기 때문에 사전에 LINE과 Github을 통해 온라인 회의를 지속적으로 진행했다. 이를 통해 나는 아래와 같은 사전 준비를 하고서 Hackday에 참가하였다.</p>\n<ol>\n<li><p>MQ(Message Queue), 데이터 처리 방법 등에 대한 이해</p>\n<ul>\n<li>MQ란 무엇이고, 프로젝트에 적합한 프로젝트는 무엇인가?</li>\n<li>데이터 처리 방식 중 Batch와 Stream의 차이와 각각의 장단점은?</li>\n<li>확장성과 고가용성을 고려하였을 때 적합한 데이터 저장 및 분석 방법은?</li>\n</ul>\n</li>\n<li><p>서버 운용 및 클러스터링 계획</p>\n<ul>\n<li>사전에 할당받은 10개의 서버를 어떻게 운용할 것인가?</li>\n<li>어떤 기술 스택을 사용할 것인가?</li>\n<li>어떤식으로 Clustering할 것인가?</li>\n<li><p>어떠한 플로우로 데이터를 처리하고, 어떻게 분석할 것인가? (설계)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Container Management : Kubernetes</span><br><span class=\"line\">Message Queue : Kafka</span><br><span class=\"line\">Database &amp; Analytics Engine : Hbase + Spark</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li>컨테이너 기반 (Kubernetes)<ul>\n<li>어느 범위까지 컨테이너화할 것인가?</li>\n<li>Kubernetes Clustering은 어떻게 구성 할 것인가?</li>\n<li>Docker registry는 어떤식으로 사용할 것인가?</li>\n</ul>\n</li>\n</ol>\n<p><br></p>\n<p>그 외에도 대용량 데이터 처리임을 고려하여 어떻게하면 속도와 공간 효율성을 확보할 수 있을 지에 대한 고민을 정말 많이 했다.</p>\n<p>내가 알고 있는거라곤 ‘쿠버네티스’ 다섯 글자 뿐…<br>이때까지 이정도의 대용량 데이터 처리를 해본적이 없었고 MQ 나 Hadoop 사용 경험도 없었기 때문에 처음 접하는 것들이 대부분이었다. 책도 찾아 읽고 나름대로의 공부도 많이 해서 어느정도 설계까지는 했지만 막상 실제 인프라 구축은 막막하기만 했는데, 우리 팀에 데이터 마술사님(!)이 계셔서 초반 구축을 <del>알잘딱깔센</del> 해주셔서 🐶🍯 이었다.</p>\n<p>Hackday 준비를 하면서 공부도 많이 됐지만 능력있고 열정있는 팀원님을 보면서 특히 많이 배웠다. 최고의 팀원 최고 bbb</p>\n<p><br></p>\n<h2 id=\"D-day-Hack-day\"><a href=\"#D-day-Hack-day\" class=\"headerlink\" title=\"D-day, Hack-day\"></a>D-day, Hack-day</h2><p>Hackday 당일, 춘천으로 출발 전에 미리 모여 멘토님과 간단하게 점심 식사를 했다.<br>그린 팩토리 근처 식당에서 돈까스 먹었는데 굉장히 맷-집 이더라. JMTGR.</p>\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60395184-bb234400-9b6a-11e9-8966-64be35892e6b.jpg\" width=\"40%\"><br>??: 좋아해요? </center>\n\n<p>멘토님을 처음 뵙는 자리라 조금 긴장도 됐었는데 생각보다 편한 분위기로 얘기를 나누고 근처 카페에서 커피도 사주셔서 감사하게 먹고 그린팩토리로 향했다.</p>\n<p>하지만 모든게 평화롭고 순조로운 가운데, <strong>한가지 문제</strong>가 있었다.</p>\n<p>팀원 분 중에 한 분이 몸이 아프셔서 당일 날 못 오신 것이다. 위에서 말했다 싶이 한 팀당 3명이 팀이었고, 대부분 세 명인 가운데 갑자기 우리팀만 둘이 되었다.</p>\n<p>이 때 느낌왔다. <u>오늘 숙소 구경은 물건너 갔음을.</u></p>\n<p><br></p>\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60395094-3c79d700-9b69-11e9-9a2f-faf606655425.JPG\" width=\"50%\"><br><i>행사 진행 장소인 NAVER CONNECT ONE은 내부 사진 공개를 금하고 있기 때문에 시설 모습이 보이는 구체적인 사진들은 공개할 수 없다.</i></center>\n\n<p><br></p>\n<p>사실 나와 다른 팀원님은 커네트원이 두 번째 방문이라 구경은 제쳐두고 회의실에만 박혀있었어서 사진도 거의 안찍었다. 때 맞춰 나와 밥 먹고 당 떨어지면 간식 가져오는 거 외에는 회의실에 스스로를 감금했다.</p>\n<p>왜냐고? 순조롭긴 개뿔 내가 해간거 하나도 안됐다. <del>tlqk</del></p>\n<blockquote>\n<p>인프라 특 _ 이유없이 갑자기 안됨</p>\n<p>루까 특 _ 이유없긴 사실상 <strong>본인 잘못</strong>임</p>\n</blockquote>\n<p><br></p>\n<p>도착하자 마자 마음이 급했던 우리 팀은 곧 바로 회의를 시작했다. 사전에 온라인 회의를 통해 설계를 논의하긴 했었지만 확정은 아니었고, 그 이후로 각자가 고민했던 부분과 그 결과로 설계한 구조를 서로 공유하고 멘토님께 피드백을 받았다.</p>\n<p><strong><em>결론만 얘기하자면, 나와 다른 팀원님의 디자인은 완전히 달랐다.</em></strong></p>\n<p>같은 문제를 접했고 사용할 인프라도 같이 정했음에도 불구하고, 생각하는 해결 방식이 다른 것이다. 이런 점이 사실 놀랍기도 하고 또 각 방법의 장단점이 분명해서 어떤 설계에 따라 구현할지 토의를 하면서 많은 고민이 되었다. 결국 일단은 내 설계대로 진행하기로 결론을 냈지만, 여기의 가장 큰 이슈는 <u>Hackday 기간 안에 구현이 가능할지</u> 였다. </p>\n<blockquote>\n<p>✽ 프로젝트 내용은 공개 가능한 범위가 모호하여 일단 보류하고, 추후에 기회가 되는대로 짰던 코드와 함께 겪었던 문제점, 해결 과정, 느낀점 등을 따로 정리하려 한다.</p>\n</blockquote>\n<p><br></p>\n<h4 id=\"‘혹시’하면-‘역시’다\"><a href=\"#‘혹시’하면-‘역시’다\" class=\"headerlink\" title=\"‘혹시’하면 ‘역시’다.\"></a>‘혹시’하면 ‘역시’다.</h4><center><img src=\"https://user-images.githubusercontent.com/26691216/60401215-0ebc7e80-9bb9-11e9-90bf-d301476adcce.gif\" alt=\"c4796fa2653be1d6726b90fe3189184d\"></center><br><center><i>서버들은 이유 없이 돌아가며 터지고, <br><br>Kubernetes는 갑자기 막혔고, <br><br>Hbase Cluster도 급 터져 팀원님이 해결하시는 와중에 <br><br>우려 했던 나의 Spark (정확히는 Scalar) 멘붕까지 <strong>터!져! Ba!by!</strong><br><br></i></center> \n\n<p>새로운 도메인 지식 습득과 설계에 급급했던 나머지 나는 초반 인프라 구축 참여가 적었고 거기에 대한 이해도가 다소 부족했다. 그 중 Kafka는 비교적 많이 공부를 해갔지만 DB 쪽에는 신경을 많이 쓰지 못했더니,</p>\n<p><strong>Java로 Consumer와 Producer를 구현하긴 했는데 막상 데이터를 어떻게 다뤄야 되는지를 모르겠는 거다.</strong></p>\n<p>다른 팀원님이 DB 문제를 해결하고 계시는 동안 혼자 Consumer 모듈에 Spark를 적용해보려니 눈앞이 캄캄했다. 밤새 Spark가 대체 뭐며 어떻게 적용해야 하는지를 찾아봐도 참고하라고 주신 Scalar 코드를 봐도 좀 처럼 각이 안나왔다.<br>이 때 사실 팀원분이 데이터 처리 경험이 나보다 많다는 이유로 나는 너무 안일하게 준비한게 아닌가라는 반성을 많이 했다.</p>\n<p>예상했던 대로 <u>그 좋은 숙소는 주인 없는 밤을 보내게 되었다</u>. 🛏</p>\n<p><br><br><br></p>\n<p>다음 날 점심 식사 후, 최종 결과물을 멘토님께 공유하고 피드백을 받았다.</p>\n<p>처음에는 팀 프로젝트였지만 진행하다보니 계획했던 결과를 내기에는 부족함이 있어 결국 팀원 각자 나름의 구현 결과물을 내게 되었다.<br>(각자의 설계를 기반으로 하되, 각자가 처한 상황에 따라 스펙을 조금씩 바꾸었다)</p>\n<p>밤새 구현한 걸 몇 번이고 뒤집어 엎어 최종적으로 계획 했던 동작은 구현하긴 했지만 ‘대용량 데이터 처리’와 ‘컨테이너 환경’에 대한 아쉬움은 어쩔 수 없었다. 이렇게 아쉬움을 한 가득 안고 <strong>Campus Hackday</strong>는 마무리 되었지만, 또 배워가는 것도 한 가득이라 여러모로 의미가 큰 행사였다.</p>\n<p><br></p>\n<h2 id=\"After\"><a href=\"#After\" class=\"headerlink\" title=\"After ..\"></a>After ..</h2><p>Hackday를 다녀와서 가장 먼저는 <strong>잤다</strong>. 즈질 체력 증말;;</p>\n<p>그러고나서 까먹기 전에 부족했던 점과 배운 점을 정리하면서<br>멘토님께 피드백 받은 부분과 스스로 아쉬웠던 부분은 인프라가 아직 남아있을 때 공부하면서 보완해보고자 했다.</p>\n<center><img src=\"https://user-images.githubusercontent.com/26691216/60398767-339ffa00-9b97-11e9-9caa-05023dba1d11.png\" width=\"210\"><br><del>사람이 안하던 짓을 하면…</del> </center>\n\n<p>생각했던 것보다 서버 회수 시기가 앞당겨져서 아쉽기는 했지만, 아쉬운대로 로컬에 최대한 동일한 테스트 환경을 구축해서 Code Refactoring / Test 와 정리한 내용 바탕의 문서 작성을 마치고 팀 Github에 Issue와 PR을 올림으로써 Hackday 프로젝트를 마무리 지었다.</p>\n<hr>\n<p><br></p>\n<h4 id=\"느낀점\"><a href=\"#느낀점\" class=\"headerlink\" title=\"느낀점\"></a>느낀점</h4><p>Naver Campus Hackday와 다른 해커톤과의 차이점은 실무에 어느정도 직접적인 연관이 있는 문제들을 접하고 그 중 본인이 관심있는 주제를 정할 수 있다는 점이고, 1박 2일 행사 기간 외에도 문제에 대해 좀 더 깊게 고민하고 개발할 수 있는 시간이 있다는 것이다. </p>\n<p>그리고 또 다른 큰 차이점은 <strong>‘경쟁이나 시험이 아니다’</strong> 라는 것이다.<br>다른 팀과의 내용 공유가 따로 없어 어떤 걸 어떻게 해결하셨는지 정말 궁금하긴 했지만, 대신에 비교도 없고 경쟁도 없다. </p>\n<p>물론 우수참가자에게는 네이버 인턴 면접기회를 준다는 혜택이 분명 존재하지만, 멘토님도 여러 차례 강조하셨던 것 처럼 정해진 답을 찾는다기보다 <u>실제 실무에서의 문제를 접하고 해결하는 경험</u>을 할 수 있는 기회이다. 경쟁이 아닌 또래의 열정적이고 실력있는 분들을 만나 많이 배우고 자극을 받을 수 있는 점이나, 현업의 네이버 개발자님의 멘토링과 피드백을 받을 수 있는 점 모두 다른 곳에서 경험 할 수 없는 귀한 경험인 것 같다.</p>\n<p>끝나고 가장 아쉬웠던 점 중 하나는 사전에 좀 더 많은 시간을 투자해서 당일에는 좀 더 활발한 네트워킹과 구체적인 피드백 (+ 코드 리뷰) 을 받을 수 있었으면 더 좋지 않았을까 하는 것이다. </p>\n<blockquote>\n<p><em>‘Hackathon’</em> 이라고 생각하고 <em>‘Hackday’</em> 를 충분히 즐기지 못했던게 아쉽긴하지만,<br>근래 조금은 지쳤던 나에게 <strong><em>좋은 자극</em></strong> 이 되었음에는 틀림 없다.  </p>\n</blockquote>\n<p><br></p>\n<p>혹시나 Naver Campus Hackday 참가를 희망하거나 이미 합격하신 분이 이 글을 읽는다면 조금의 도움이 되시길 바라며 글을 마친다.</p>\n<p><br></p>\n<p>아디다디도스! 👋🏻</p>\n<p><br></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjxlyib2g00001n4y6f1f69fr","category_id":"cjxlyib2m00021n4yw4hf6vo4","_id":"cjxlyib2p00051n4y6g6a2u5z"},{"post_id":"cjxlyibcv000c1n4yuj8d9ci8","category_id":"cjxlyibcy000e1n4y9k38c21g","_id":"cjxlyibcz000i1n4yaa335gpt"},{"post_id":"cjxlyibcw000d1n4y049nt5eb","category_id":"cjxlyibcy000g1n4y5d267i7o","_id":"cjxlyibcz000k1n4y98f4o4dx"}],"PostTag":[{"post_id":"cjxlyib2g00001n4y6f1f69fr","tag_id":"cjxlyib2n00031n4ybg0ek343","_id":"cjxlyib2s00081n4y86atkm3e"},{"post_id":"cjxlyib2g00001n4y6f1f69fr","tag_id":"cjxlyib2o00041n4ycw1xv6pe","_id":"cjxlyib2s00091n4yobd9hq2x"},{"post_id":"cjxlyib2g00001n4y6f1f69fr","tag_id":"cjxlyib2q00061n4y2l7707ww","_id":"cjxlyib2s000a1n4yflq9fmz6"},{"post_id":"cjxlyib2g00001n4y6f1f69fr","tag_id":"cjxlyib2r00071n4yjzdprr5x","_id":"cjxlyib2s000b1n4ytwrrvrbr"},{"post_id":"cjxlyibcv000c1n4yuj8d9ci8","tag_id":"cjxlyibcy000f1n4y5yzssgd9","_id":"cjxlyibd0000n1n4y1q6pw3xp"},{"post_id":"cjxlyibcv000c1n4yuj8d9ci8","tag_id":"cjxlyibcz000h1n4y7rb208b0","_id":"cjxlyibd0000o1n4yijg38cce"},{"post_id":"cjxlyibcv000c1n4yuj8d9ci8","tag_id":"cjxlyibcz000j1n4ydrie2pat","_id":"cjxlyibd0000q1n4y3oq1wusg"},{"post_id":"cjxlyibcv000c1n4yuj8d9ci8","tag_id":"cjxlyibcz000l1n4yqui3n72w","_id":"cjxlyibd0000r1n4yrilvbmfz"},{"post_id":"cjxlyibcw000d1n4y049nt5eb","tag_id":"cjxlyibd0000m1n4y92lu6icp","_id":"cjxlyibd3000v1n4yer59p0ah"},{"post_id":"cjxlyibcw000d1n4y049nt5eb","tag_id":"cjxlyibd0000p1n4yzsus7p9t","_id":"cjxlyibd3000w1n4ylmf1t7tl"},{"post_id":"cjxlyibcw000d1n4y049nt5eb","tag_id":"cjxlyibcz000j1n4ydrie2pat","_id":"cjxlyibd3000x1n4yaysxji90"},{"post_id":"cjxlyibcw000d1n4y049nt5eb","tag_id":"cjxlyibd2000t1n4yo8z3es5d","_id":"cjxlyibd3000y1n4yw62jp9yu"},{"post_id":"cjxlyibcw000d1n4y049nt5eb","tag_id":"cjxlyibcz000l1n4yqui3n72w","_id":"cjxlyibd3000z1n4yffkrpv8u"}],"Tag":[{"name":"kotlin","_id":"cjxlyib2n00031n4ybg0ek343"},{"name":"study","_id":"cjxlyib2o00041n4ycw1xv6pe"},{"name":"book","_id":"cjxlyib2q00061n4y2l7707ww"},{"name":"summarization","_id":"cjxlyib2r00071n4yjzdprr5x"},{"name":"kubernetes","_id":"cjxlyibcy000f1n4y5yzssgd9"},{"name":"k8s","_id":"cjxlyibcz000h1n4y7rb208b0"},{"name":"container","_id":"cjxlyibcz000j1n4ydrie2pat"},{"name":"CNCF","_id":"cjxlyibcz000l1n4yqui3n72w"},{"name":"naver","_id":"cjxlyibd0000m1n4y92lu6icp"},{"name":"hackathon","_id":"cjxlyibd0000p1n4yzsus7p9t"},{"name":"kafka","_id":"cjxlyibd2000t1n4yo8z3es5d"}]}}